// Generated by CoffeeScript 2.6.1
(function() {
  var indexOf = [].indexOf;
  const ldc_annotate_get_workflow = () => {};
  window.ldc_source = (function() {
    var active_channel, additional_play_callback, after_select_text_callback, after_unselect_text_callback, all_srcs, array2html, audio_context, audio_elements, audio_looping, categorize_transcript_lines_by_menu_selector, categorize_transcript_lines_by_menu_values, collision, current_audio_node, current_src, currently_playing_audio, currently_playing_offset, currently_playing_source, currently_playing_start_time, currently_playing_stop_time, curtext, debug, div2sel, draw_underlines_flag, engine, first_src, force_font_size, get, get_init, get_init_aws, get_init_aws2, getp, getp_aws, getp_aws2, htmlEscape, jsons, line_char_limit, looping, ltf, messageIdIndexMap, multipart, multipart_child, overplay, playing, post, post_init, postp, psm, queue, queue_i, responsef, round_to_1_place, round_to_2_places, round_to_3_places, round_to_6_places, selected_text, sources, split_line_margin, srcs, stereo, text_capture, transcript_line_selector, underline_callback, underline_height, wave, wave_active_transcript_line, zoom;
    htmlEscape = function(str) {
      return String(str).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    };
    round_to_1_place = function(num) {
      return Math.round(num * 10) / 10;
    };
    round_to_2_places = function(num) {
      return Math.round(num * 100) / 100;
    };
    round_to_3_places = function(num) {
      return Math.round(num * 1000) / 1000;
    };
    round_to_6_places = function(num) {
      return Math.round(num * 1000000) / 1000000;
    };
    jsons = function(obj) {
      return JSON.stringify(obj);
    };
    get_init = function() {
      return {
        headers: {
          'content-type': 'application/json',
          'Accept': 'application/json',
          'X-CSRF-Token': $('meta[name="csrf-token"]').attr('content')
        },
        credentials: 'same-origin'
      };
    };
    post_init = function(o) {
      var h;
      h = get_init();
      h.method = 'POST';
      h.body = jsons(o);
      return h;
    };
    responsef = function(r) {
      var type;
      if (r.ok) {
        type = r.headers.get("content-type");
        if (type && type.includes("application/json")) {
          return r.json();
        } else if (type && type.includes("text/plain")) { // s3 site doesn't know files are json
          return r.json();
        } else if (type && type.includes("text/html")) { // s3 site doesn't know files are json
          return r.json();
        } else if (type && type.includes("text/xml")) {
          return r.text();
        } else if (type && type.includes("audio/wav")) {
          return r.arrayBuffer();
        } else if (type && type.includes("audio/x-wav")) {
          return r.arrayBuffer();
        }
      }
      throw new Error('response error' + type);
    };
    getp = function(url) {
      return fetch(url, get_init()).then(responsef).catch(function(e) {
        return console.error('Error:', e);
      });
    };
    postp = function(url, o) {
      return fetch(url, post_init(o)).then(responsef).catch(function(e) {
        return console.error('Error:', e);
      });
    };
    get = function(url, f) {
      return getp(url).then(f);
    };
    post = function(url, o, f) {
      return postp(url, o).then(f);
    };
    get_init_aws = function() {
      return {
        headers: {
          'content-type': 'text/plain' // s3 won't accept application/json due to cors?
        }
      };
    };
    getp_aws = function(url) {
      return fetch(url, get_init_aws()).then(responsef).catch(function(e) {
        return console.error('Error:', e);
      });
    };
    get_init_aws2 = function() {
      return {
        headers: {
          "Cache-Control": "no-cache, no-store"
        }
      };
    };
    getp_aws2 = function(url) {
      return fetch(url, get_init_aws2()).then(responsef).catch(function(e) {
        return console.error('Error:', e);
      });
    };
    array2html = function(a) {
      var children, i, name, s;
      if (a === null) {
        return '';
      }
      name = a[0];
      children = a[a.length - 1];
      s = '<' + name;
      i = 1;
      while (a.length > i + 1) {
        s += ` ${a[i]}=\"${a[i + 1]}\"`;
        i += 2;
      }
      if (children instanceof Array) {
        if (children.length > 0) {
          s += '>';
          $.each(children, function(x, y) {
            return s += array2html(y);
          });
          return `${s}</${name}>`;
        } else {
          return `${s}/>`;
        }
      } else {
        return `${s}>${children}</${name}>`;
      }
    };
    ltf = false;
    curtext = null; // current Text node
    text_capture = false;
    after_select_text_callback = function(n) {
      return null;
    };
    after_unselect_text_callback = function(n) {
      return null;
    };
    additional_play_callback = function(x, y) {
      return null;
    };
    line_char_limit = 70;
    selected_text = {}; // map selectors to character ranges
    messageIdIndexMap = {}; //this maps the message id to the index in the message array
    sources = {}; //key is the docid, value is the source data returned for a doc
    window.sources = sources;
    psm = null;
    current_src = null;
    first_src = null;
    srcs = {}; // individual pointers
    underline_callback = function(x) {
      return alert('default callback');
    };
    engine = 'engine4';
    div2sel = function(div) {
      return '#' + div.id;
    };
    force_font_size = null;
    // engine1:  text is text, underlines are drawn
    // engine2:  text is also drawn (unfinished)
    // engine3:  single canvas, rather than canvas per line (unfinished)
    // engine4:  same as engine1, but with <span> tags around each character
    underline_height = 5;
    // audio functionality
    wave = null;
    // wave_offset = null # for current selection
    // wave_length = 0 # for current selection
    // wave_end = null # for current selection, needed for the way change is detected
    // wave_display_length = null # seconds, for waveform display
    // wave_display_offset = null # ditto
    // wave_canvas_width = null # pixels
    // wave_canvas_height = null # pixels
    // wave_audio = null
    transcript_line_selector = null;
    categorize_transcript_lines_by_menu_selector = null;
    categorize_transcript_lines_by_menu_values = [];
    wave_active_transcript_line = null;
    draw_underlines_flag = false;
    queue = [];
    queue_i = 0;
    looping = false;
    audio_looping = false;
    // waveform = {}
    // waveform2 = {}

    // web_audio = false
    // when false, use haejoong's library
    // when true, use web audio, implemented within this module
    collision = null;
    // play_mode = 'normal'
    all_srcs = [];
    // haejoong's player has three states
    // player_state = 'stopped' # playing paused
    // for my web audio implementation, just use two states
    playing = false;
    // play_head = 0
    audio_context = null;
    // if we used the <audio> element (or just Audio object) and MediaElementAudioSourceNode we wouldn't need an AudioBuffer
    // but that approach seems to deny some of the flexibility we want
    // so, opt for limiting file size
    // wave_buffer = null # holds an AudioBuffer
    // wave_buffer_sample_rate = null
    // wave_buffers = {}

    // audio_element = null
    audio_elements = {};
    // only assign to one of these to distinguish the different modes
    currently_playing_source = null; // AudioBufferSourceNode
    currently_playing_audio = null; // MediaElementAudioSourceNode
    overplay = null;
    currently_playing_start_time = 0;
    currently_playing_stop_time = 0;
    currently_playing_offset = 0;
    current_audio_node = null;
    // spectrogram_flag = false
    debug = false;
    zoom = false;
    multipart = false;
    multipart_child = null;
    stereo = false;
    active_channel = 0;
    split_line_margin = 0.1;
    return {
      easy_get: function(url) {
        return fetch(url, get_init()).then(responsef).catch(function(e) {
          return console.error('Error:', e);
        });
      },
      set_force_font_size: function(size) {
        return force_font_size = size;
      },
      set_text_capture: function(b) {
        return text_capture = b;
      },
      set_after_select_text_callback: function(f) {
        return after_select_text_callback = f;
      },
      set_after_unselect_text_callback: function(f) {
        return after_unselect_text_callback = f;
      },
      select_text: function(n, message_id) {
        var a, b, c, chr, chra, chrb, chrc, found, i, l, list, obj, prefix, range, ref, ref1, text, workflow;
        console.log(n);
        if (window.getSelection().rangeCount > 0) {
          console.log(n);
          range = window.getSelection().getRangeAt(0);
          window.getSelection().removeAllRanges();
          list = $('#node-' + n).data().meta.selection;
          list.beg = range.startContainer.parentNode.id;
          list.end = range.endContainer.parentNode.id;
          obj = $('.Root').data().obj;
          if (obj.snap_to_sentence) {
            a = ldc_annotate.get_offset(list.beg);
            found = null;
            sources[obj.snap_to_sentence.docid].then(function(sorc) {
              $.each(sorc.segments, function(i, x) {
                if (found === null && x[0] <= a && x[1] >= a) {
                  return found = x;
                }
              });
              if (found) {
                list.beg = `#node-${n}-char-${found[0]}`;
                return list.end = `#node-${n}-char-${found[1]}`;
              }
            });
          }
          //originally used range.toString(), but it missed spaces at the end of lines, so need to adjust
          text = '';
          prefix = ldc_annotate.get_offset_prefix(list.end);
          a = ldc_annotate.get_offset(list.beg);
          b = ldc_annotate.get_offset(list.end);
          // console.log "OFFSETS #{a} #{b}"
          // fix final space problem
          chra = $(prefix + a).html();
          chrb = $(prefix + b).html();
          if (chrb === ' ' && chra !== ' ') {
            c = b - 1;
            chrc = $(prefix + c).html();
            if (chrc !== null && chrc !== void 0) {
              list.end = prefix.replace('#', '') + c;
              b = c;
            }
          }
          for (i = l = ref = a, ref1 = b; (ref <= ref1 ? l <= ref1 : l >= ref1); i = ref <= ref1 ? ++l : --l) {
            // chr = $(prefix + i).html()
            chr = $(prefix + i).text();
            if (chr !== null && chr !== void 0) {
              text += chr;
              if (ltf) { //null indicates we can't find the char's id and corresponds to a space that occurs where the line breaks
                text += ' ';
              }
            } else {
              if (!ltf) {
                text += ' ';
              }
            }
          }
          if (message_id) {
            list.message_id = message_id;
          }
          console.log(`color? #node-${n}`);
          this.color_text(`#node-${n}`, 'pink');
          list.text = text;
          workflow = ldc_annotate_get_workflow();
          if (b - a > 0) {
            console.log('here');
            return after_select_text_callback(`#node-${n}`);
          }
        }
      },
      // @param {String} n - text node id (often rsd uid), ex. 'IC001K26V'
      // @param {Integer} x - start character offset
      // @param {Integer} y - end character offset
      // @returns null - highlights text in pink, sets selection on text node
      select_text_by_chars: function(n, x, y) {
        var list, selector;
        selector = `#node-${n}`;
        list = $(selector).data().meta.selection;
        list.beg = `node-${n}-char-${x}`;
        list.end = `node-${n}-char-${y}`;
        return this.select_text_by_chars_helper(selector);
      },
      select_text_by_chars_helper: function(selector) {
        var a, b, i, l, list, prefix, ref, ref1, text, workflow;
        list = $(selector).data().meta.selection;
        //originally used range.toString(), but it missed spaces at the end of lines, so need to adjust
        text = '';
        if (!(list.beg && list.end)) {
          return;
        }
        prefix = ldc_annotate.get_offset_prefix(list.end);
        a = ldc_annotate.get_offset(list.beg);
        b = ldc_annotate.get_offset(list.end);
        for (i = l = ref = a, ref1 = b; (ref <= ref1 ? l <= ref1 : l >= ref1); i = ref <= ref1 ? ++l : --l) {
          if ($(prefix + i).html() !== null) {
            text += $(prefix + i).html(); //null indicates we can't find the char's id and corresponds to a space that occurs where the line breaks
          } else {
            text += ' ';
          }
        }
        this.color_text(selector, 'pink');
        list.text = text;
        workflow = ldc_annotate_get_workflow();
        if (b - a > 0) {
          return after_select_text_callback(selector);
        }
      },
      set_level_behavior: function(node_classes) {
        var buttons, div, labels, level, menu, that, values;
        that = this;
        console.log("/node_classes/5412");
        level = null;
        menu = null;
        $.each(node_classes, function(x, y) {
          var a;
          if (y.value.level) {
            a = y.value.level.split(',');
            // console.log a[0]
            // console.log a[1]
            that.set_underline_height(parseInt(a[2]));
            return $.each(node_classes, function(x, y) {
              if (menu) {
                return;
              }
              if (y.name === a[1]) {
                menu = y;
                return level = parseInt(a[0]);
              }
            });
          }
        });
        if (menu) {
          values = menu.value.values;
          labels = menu.value.labels;
          buttons = [];
          div = ['div', 'id', 'underlines-buttons', 'class', 'btn-group', buttons];
          $.each(labels, function(i, x) {
            var y;
            y = x[0];
            return buttons.push(['button', 'class', 'btn underlines-button', 'ivalue', values[i], [['span', y], ['span', ' '], ['span', x]]]);
          });
          ldc_source.set_after_select_text_callback(function(selector) {
            var mysrcs, value;
            // console.log $(selector).data()
            value = ldc_annotate.get_value_from_current_selection();
            value.level = 0;
            mysrcs = [];
            $('.Text').each(function(i, x) {
              return mysrcs.push($(x).data().value);
            });
            if (that.collides_set(value, mysrcs) === true) {
              return;
            }
            console.log(value);
            return console.log(mysrcs);
          });
          // ldc_source.add_underlines_buttons div
          return $('.Root').on('click', '.underlines-button', function() {
            var value;
            // return unless ldc_annotate.is_text_selected()
            // return unless ldc_source.get_current_docid()

            // ldc_annotate.submit_form()
            value = ldc_annotate.get_value_from_current_selection();
            ldc_annotate.unselect_text(ldc_annotate.get_curtextsource());
            ldc_annotate.add_list_item_to_list('.List');
            ldc_annotate.add_message('new.Menu', 'change', {
              value: $(this).attr('ivalue')
            });
            ldc_annotate.add_message('new.Text', 'change', value);
            return ldc_annotate.submit_form();
          });
        }
      },
      add_underlines_buttons: function(div) {
        var left, selection;
        selection = ldc_annotate.get_value_from_current_selection();
        $(selection.display_selector + "-char-" + selection.end).parent().after(array2html(div));
        left = $(selection.display_selector + "-char-" + selection.beg).offset().left;
        return $('#underlines-buttons').offset({
          left: left
        });
      },
      //this function removes the current selection, if any
      unselect_text: function(n) {
        var data, meta;
        if (n) {
          data = $('#node-' + n).data();
          if (!data) {
            console.error(`node ${n} not defined for kit ${$('.Root').data().obj._id}`);
          }
          meta = data.meta;
          if (meta.selection && meta.selection.beg) {
            this.color_text(`#node-${n}`, '');
          }
          meta.selection = {
            beg: null,
            end: null,
            text: null
          };
        }
        after_unselect_text_callback(n);
        return $('#underlines-buttons').remove();
      },
      //this function colors a block of already selected text
      color_text: function(selector, color) {
        var beg, end, list, prefix, tmp;
        list = $(selector).data().meta.selection;
        beg = ldc_annotate.get_offset(list.beg);
        end = ldc_annotate.get_offset(list.end);
        prefix = ldc_annotate.get_offset_prefix(list.end);
        //swaps the begin and end variables if they are reversed
        if (beg > end) {
          tmp = beg;
          beg = end;
          end = tmp;
        }
        return this.color_text_helper(prefix, beg, end, color);
      },
      color_text_helper: function(prefix, beg, end, color) {
        return this.character_helper(prefix, beg, end, 'background-color', color);
      },
      character_helper: function(prefix, beg, end, property, value) {
        var that;
        that = this;
        return setTimeout(function() {
          var i, l, q, ref, ref1, ref2, ref3, results;
          if ($(prefix + end).length === 1) {
//sets the background color for each character
            for (i = l = ref = beg, ref1 = end; (ref <= ref1 ? l <= ref1 : l >= ref1); i = ref <= ref1 ? ++l : --l) {
              $(prefix + i).css(property, value);
            }
            if (prefix.match(/-line-/)) {
              prefix = prefix.replace('line', 'underlines');
              results = [];
              for (i = q = ref2 = beg, ref3 = end; (ref2 <= ref3 ? q <= ref3 : q >= ref3); i = ref2 <= ref3 ? ++q : --q) {
                results.push($(prefix + i).css(property, value));
              }
              return results;
            }
          } else {
            return that.character_helper(prefix, beg, end, property, value);
          }
        }, 100);
      },
      set_underline_height: function(x) {
        return underline_height = x;
      },
      set_line_char_limit: function(x) {
        return line_char_limit = x;
      },
      find_remainder: function(waveform) {
        var all, did_collide, remainder, that;
        that = this;
        remainder = [
          {
            beg: 0,
            end: wave_audio.etime
          }
        ];
        did_collide = true;
        all = [];
        $.each(srcs[waveform.wave_docid], function(i, x) {
          return all.push({
            beg: x.beg,
            end: x.end
          });
        });
        while (did_collide === true) {
          did_collide = false;
          $.each(all, function(i, src) {
            var temp;
            if (that.collides_set(src, remainder)) {
              did_collide = true;
              if (collision.beg < src.beg) {
                temp = collision.end;
                collision.end = src.beg - 0.001;
                if (temp > src.end) {
                  return remainder.push({
                    beg: src.end + 0.001,
                    end: temp
                  });
                }
              } else {
                return collision.beg = src.end + 0.001;
              }
            }
          });
        }
        remainder.sort(function(a, b) {
          return a.beg - b.beg;
        });
        return remainder;
      },
      custom_play_callback: function(current_audio_node, playing) {
        return null;
      },
      set_audio_context: function() {
        return audio_context = window.ldc.vars.audio_context;
      },
      // calling functions need to decide whether stop_playing should be called first, then play_this_span
      write_to_hud: function(audio) {
        var getbuffers, x;
        return;
        getbuffers = function(x) {
          var i, l, ref, results;
          if (x.length === 0) {
            return ["empty"];
          }
          results = [];
          for (i = l = 0, ref = x.length - 1; (0 <= ref ? l <= ref : l >= ref); i = 0 <= ref ? ++l : --l) {
            results.push(`${x.start(i)} ${x.end(i)}`);
          }
          return results;
        };
        console.log("OVERPLAY");
        console.log(overplay);
        return $('#hud').html(ldc_nodes.array2html([
          'div',
          [
            [
              'div',
              (function() {
                var l,
              len,
              ref,
              results;
                ref = ['paused', 'crossOrigin', 'currentTime', 'duration', 'ended', 'error', 'networkState', 'preload', 'readyState', 'seeking', 'volume'];
                results = [];
                for (l = 0, len = ref.length; l < len; l++) {
                  x = ref[l];
                  results.push(['div',
              `${x}: ${audio[x]}`]);
                }
                return results;
              })()
            ],
            ['div',
            `overplay: ${audio.currentTime - overplay}`],
            ['div',
            'buffered'],
            [
              'div',
              (function() {
                var l,
              len,
              ref,
              results;
                ref = getbuffers(audio.buffered);
                results = [];
                for (l = 0, len = ref.length; l < len; l++) {
                  x = ref[l];
                  results.push(['div',
              x]);
                }
                return results;
              })()
            ],
            ['div',
            'played'],
            [
              'div',
              (function() {
                var l,
              len,
              ref,
              results;
                ref = getbuffers(audio.played);
                results = [];
                for (l = 0, len = ref.length; l < len; l++) {
                  x = ref[l];
                  results.push(['div',
              x]);
                }
                return results;
              })()
            ],
            ['div',
            'seekable'],
            [
              'div',
              (function() {
                var l,
              len,
              ref,
              results;
                ref = getbuffers(audio.seekable);
                results = [];
                for (l = 0, len = ref.length; l < len; l++) {
                  x = ref[l];
                  results.push(['div',
              x]);
                }
                return results;
              })()
            ]
          ]
        ]));
      },
      set_draw_underlines_flag: function(x) {
        return draw_underlines_flag = x;
      },
      deprioritize_current: function(lists) {
        var list, previous;
        console.log('current');
        list = $('.current_display').data().meta.id;
        console.log(lists[list]);
        console.log(list);
        if (lists[list].beg) {
          previous = lists[list];
        }
        ldc_annotate.unselect_text(list);
        console.log(list);
        if (previous) {
          return this.color_text(`#node-${previous}`, 'green');
        }
      },
      spectrogram: function(b) {
        var spectrogram_flag;
        return spectrogram_flag = b;
      },
      load_segment: function(x) {
        if (x.docid) {
          return this.get_audio_file2(x.docid, x.beg, x.end);
        }
      },
      data_set_urls: function(d) {
        var base, urls;
        urls = {};
        $.each(d["data"], function(i, x) {
          var a, y;
          a = x.split('/');
          y = a[a.length - 1].split('.').slice(0, -1).join('.');
          return urls[y] = x;
        });
        (base = window.ldc).resources || (base.resources = {});
        return window.ldc.resources.urls = urls;
      },
      set_current_selection_by_src: function(src) {
        return this.set_current_selection(src.beg, src.end - src.beg);
      },
      // these functions will work for entries as well, any widget that responds to data().value.value
      set_categorize_transcript_lines_by_menu_selector: function(selector, values) {
        categorize_transcript_lines_by_menu_selector = selector;
        return categorize_transcript_lines_by_menu_values = values;
      },
      categorize_transcript_lines_by_menu: function(menu_selector) {
        var lines;
        lines = {
          rest: []
        };
        $.each(categorize_transcript_lines_by_menu_values, function(i, x) {
          return lines[x] = [];
        });
        $(menu_selector).each(function(i, x) {
          var v;
          v = $(x).data().value.value;
          if (lines.hasOwnProperty(v)) {
            return lines[v].push($(x).parents(transcript_line_selector)[0]);
          } else {
            return lines.rest.push($(x).parents(transcript_line_selector)[0]);
          }
        });
        return lines;
      },
      categorize_transcript_lines_by_values: function(menu_selector) {
        var lines, obj;
        lines = {};
        obj = {
          keys: [],
          values: lines
        };
        $(menu_selector).each(function(i, x) {
          var v;
          v = $(x).data().value.value;
          if (lines.hasOwnProperty(v)) {
            return lines[v].push($(x).parents(transcript_line_selector)[0]);
          } else {
            lines[v] = [$(x).parents(transcript_line_selector)[0]];
            return obj.keys.push(v);
          }
        });
        return obj;
      },
      // these should probably go away eventually, they're a legacy from ldc_annotate
      set_curtext: function(x) {
        return curtext = x;
      },
      get_curtext: function() {
        return curtext;
      },
      delete_text_annotation: function(node) {
        var node_id, that;
        that = this;
        node_id = node.meta.id;
        that.remove_source(node.value.docid, node_id);
        //changing_list_item = true;
        ldc_annotate.add_message(node_id, 'change', {
          docid: null,
          beg: null,
          end: null
        });
        return curtext = null;
      },
      ban_quotes: function(value) {
        var quotes;
        console.log('value');
        console.log(value);
        quotes = sources[value.docid].quotes;
        if (quotes[value.beg] > 0 || quotes[value.end] > 0) {
          alert("you can't annotate inside quote tags");
          return false;
        } else {
          return true;
        }
      },
      eyeball: function(n, workflow, source_transform, curdocid) {
        var id, id_prefix, textsource_id, that, value;
        that = this;
        if ($(`#node-${n}`).length === 0) {
          console.error(`node ${n} missing`);
        }
        value = $(`#node-${n}`).data().value;
        this.set_curtext(n);
        if (workflow.hasOwnProperty('getActiveTextSource2') === true) {
          that.set_current_display(workflow['getActiveTextSource2']());
        }
        if (value.docid) {
          if (source_transform === false && curdocid !== value.docid) {
            return this.show_source(value);
          } else {
            value['pane'] = 'None';
            that.show_source(value);
            // console.log('ACTIVATING')                # console.log( value )
            if (workflow.hasOwnProperty('getActiveTextSource') === true) {
              textsource_id = workflow['getActiveTextSource']();
              id_prefix = textsource_id + '-char-';
              window.location.hash = id_prefix + value.beg;
              ldc_annotate.select_annotated_text(textsource_id, id_prefix, value);
              return $(textsource_id).focus();
            } else {
              id = $('.current_display').data().meta.id;
              return that.select_text_by_chars(id, value.beg, value.end);
            }
          }
        }
      },
      set_text_events1: function(workflow, source_transform, curdocid) {
        var that;
        // previously this tested the text_capture flag, but took no action if it was false
        that = this;
        //this listener displays text in text source widgets after clicking the eye icon next to the annotated text
        $('.Root').on('click', '.Text .icon-eye-open', function(e) {
          $('a:contains("Split View")').click();
          $('.rsd').click();
          return that.eyeball($(this).parents('.Text').data().meta.id, workflow, source_transform, curdocid);
        });
        $('.Root').on('click', '.Ref .ref-text', function(e) {
          var n;
          n = $(this).parents('.Ref').data().value.value;
          return that.eyeball($(this).parents('.Ref').data().value.value, workflow, source_transform, curdocid);
        });
        $('.Root').on('click', '.show_mention', function(e) {
          var n;
          e.stopPropagation();
          n = $(this).parents('.coref_mention').attr('id').replace('coref-mention-', '');
          n = $(`#node-${n}`).siblings('.FillerText, .ExistingFillerText, .MentionText').data().meta.id;
          return that.eyeball(n, workflow, source_transform, curdocid);
        });
        $('.Root').on('click', '.show_entity_mention', function(e) {
          var n;
          n = $(this).parents('.mention').attr('id').replace('mention-', '');
          n = $(`#node-${n}`).find('.FillerText, .ExistingFillerText').data().meta.id;
          return that.eyeball(n, workflow, source_transform, curdocid);
        });
        //this listener annotates text from a textsource widget into the text widget that has been selected
        $('.Root').on('keypress', '.Text', function(e) {
          var node, node_id;
          if ($(this).hasClass('Document')) {
            return;
          }
          node = $(this).data();
          node_id = node.meta.id;
          if (debug === true) {
            console.log(`node ${node_id}`);
            console.log(`key ${e.which}`);
            console.log(`keycodex ${e.keyCode}`);
          }
          switch (e.which) {
            case 13:
              if (node.meta.readonly === true) {
                return;
              }
              //enter key, making an annotation
              return ldc_annotate.annotate_current_text(node_id);
            case 100:
              if (node.meta.readonly === true) {
                return;
              }
              //'d' key, deleting an annotation without making a new one
              return that.delete_text_annotation(node);
          }
        });
        // this listener selects text in text source widgets
        $('.Root').on('mouseup', '.line', function(e) {
          var node_id, x, y;
          //if we are in text capture mode and the left mouse button was clicked
          if (text_capture && e.which === 1) {
            node_id = ldc_lui.getNodeId($(this).parents('.Text'));
            console.log('click');
            console.log(node_id);
            x = $('.Document').height();
            y = window.innerHeight - 150;
            if (false) { //x > y
              console.log(`setting document to ${y}`);
              $('.Document').height(y);
              workflow = ldc_annotate_get_workflow();
              if (workflow && workflow.fix_height) {
                workflow.fix_height(y);
              }
            }
            that.unselect_text(node_id);
            ldc_annotate.set_curtextsource(node_id);
            //ldc_source.deprioritize_current(lists);
            that.set_current_display('#node-' + node_id);
            return ldc_annotate.select_text(node_id);
          }
        });
        // until we can properly merge the event handling, we have the following two repetitious handlers
        $('.Root').on('mouseup', '.specialline', function(e) {
          var node_id;
          //if we are in text capture mode and the left mouse button was clicked
          if (text_capture && e.which === 1) {
            // cur = $('.current_display').data().meta.id
            node_id = $(this).data().line_id.split('-')[1];
            console.log('click');
            console.log(node_id);
            that.unselect_text(node_id);
            ldc_annotate.set_curtextsource(node_id);
            that.set_current_display('#node-' + node_id);
            return ldc_annotate.select_text_fix(node_id);
          }
        });
        return $('.Root').on('click', '.underline_rect', function(e) {
          var nid;
          nid = $(this).attr('class').split('-')[2];
          return underline_callback(nid);
        });
      },
      set_text_events2: function() {
        return $('.Root').on('keypress', '.Text', function(e) {
          if (debug === true) {
            console.log(`key ${e.which}`);
            console.log(`keycode ${e.keyCode}`);
            console.log(`enter ${$.ui.keyCode.ENTER}`);
          }
          // if e.which is 13 or e.which is 100 # enter or "d"
          //     ldc_annotate.submit_form()
          if (e.keyCode === $.ui.keyCode.ENTER || e.which === 100) { // enter or "d"
            return ldc_annotate.submit_form();
          }
        });
      },
      //function to show a source from a search
      show_source_from_search: function(docid, pane, terms, current_link, doctype) {
        var task_id, workflow;
        workflow = ldc_annotate_get_workflow();
        if (!$('.Root').data()) {
          console.error(`Root not defined, docid ${docid}`);
        }
        task_id = $('.Root').data().obj.task_id;
        if (workflow) {
          this.clear_display('.current_display');
          this.show_source({
            docid: docid,
            type: doctype,
            pane: pane,
            terms: terms,
            task_id: task_id
          });
        } else {
          this.display_searched_document(docid, terms);
        }
        $('.link').removeClass('border-black');
        return current_link.addClass('border-black');
      },
      //simple function to return the current docid
      get_current_docid: function() {
        return $('.current_display').data().value.docid;
      },
      //simple function to return the source object for a docid
      get_current_source_object: function() {
        return sources[this.get_current_docid()].then(function(sorc) {
          return sorc;
        });
      },
      //this function gets the original doc (minus all markup)
      get_original_doc: function(docid) {
        return sources[docid].then(function(sorc) {
          return sorc.orig;
        });
      },
      //displays a jquery ui dialog with the text from the specified text source
      display_dialog: function(dialogId, textSourceId) {
        var src;
        this.set_current_display(dialogId);
        this.clear_display(dialogId);
        src = $(textSourceId).data().value;
        $(dialogId).dialog().dialog('option', 'title', src.docid).dialog('open');
        return sources[src.docid].then(function(sorc) {
          this.add_all_lines(src.docid, dialogId, sorc);
          return this.add_all_underlines(src.docid, sorc);
        });
      },
      set_underline_callback: function(f) {
        return underline_callback = f;
      },
      //this forunction sets the current display (TextSource widget)
      // at the moment, only a # selector will work, not a . selector
      set_current_display: function(selector) {
        return ldc_nodes.wait_for(selector, function() {
          var value;
          console.log(selector);
          if (debug === true) {
            console.log(sources);
          }
          $('.current_display').removeAttr('tabindex');
          $('.current_display').removeClass('current_display');
          $(selector).addClass('current_display');
          $(selector).attr('tabindex', 0);
          //$(selector).css('border', '1px solid red')
          value = $(selector).data().value;
          if (!$(selector).data().meta.selection) {
            // if value.docid
            //     current_docid = value.docid
            return $(selector).data().meta.selection = {};
          }
        });
      },
      //this function removes a source from our sources list, and is used by the delete annotation function
      remove_source: function(docid, node_id) {
        if (srcs[docid]) {
          if (debug) {
            if (sources[docid]) {
              sources[docid].then(function(sorc) {
                console.log('DELETE');
                return console.log(sorc.lines);
              });
            }
          }
          if (srcs[docid][node_id]) {
            if (srcs[docid][node_id].lines) {
              $.each(srcs[docid][node_id].lines, function(i, linen) {
                var list;
                list = [];
                return sources[docid].then(function(sorc) {
                  $.each(sorc.lines[linen].srcs, function(i, src) {
                    if (src.node !== node_id) {
                      return list.push(src);
                    }
                  });
                  sorc.lines[linen].srcs = list;
                  if (debug) {
                    return console.log(sorc.lines[linen].srcs);
                  }
                });
              });
            }
            return delete srcs[docid][node_id];
          }
        }
      },
      //this function updates the value of a text widget, after an annotation
      update_source: function(node) {
        var src, that;
        src = $(node).data().value;
        that = this;
        if (src.docid !== null) {
          return sources[src.docid].then(function(data) { // sorc
            var lines;
            that.add_source(node);
            lines = that.add_underlines(src, data);
            if (debug === true) {
              console.log(lines);
            }
            return $.each(lines, function(i, line) {
              var line_obj;
              if (line > 0) { //i > 0
                line_obj = data.type === 'session' ? data.lines[src.message_id][i] : data.lines[line];
                if (line_obj.srcs.length > 0) {
                  if (debug) {
                    console.log('update');
                    console.log(data);
                    console.log(line_obj);
                  }
                  return that.draw_underlines(data, line_obj);
                }
              }
            });
          });
        }
      },
      // I don't think either add_text_object or add_documen is needed for ajax-retrieved docs

      // replacement for add_document
      add_text_object: function(node) {
        var text;
        text = $(node).data().value;
        // for now, assume TextSource2 properly structured, with uid
        // Text still looks like { docid: "...", beg: 123, ... }
        if (text.uid && !text.uid.match(/^sentence/)) {
          if (debug === true) {
            console.log('addtextobject');
            console.log(text.uid);
          }
          return sources[text.uid] = Promise.resolve(text); // eventual replacement for add_source below
        } else {
          return srcs[text.docid] = text;
        }
      },
      // deprecated
      //this function adds a new document to the sources object
      add_document: function(docid, data) {
        if (debug === true) {
          console.log('sourcebeg');
          console.log(data);
          console.log(sources);
          console.log(docid);
        }
        sources[docid] = Promise.resolve(data);
        if (debug === true) {
          console.log(sources[docid]);
          return console.log('sourcend');
        }
      },
      // /        refresh_textt: function(){
      // //          sources[src.docid]
      //             $.each(srcs, function(docid, hash){
      //                 var orig = sources[docid].orig;
      //                 $.each(hash, function(n, src){
      // //                  $('#node-' + n).html(orig.substring(src.beg,src.end+1));
      //                 });
      //             });
      //         },/
      testtest: function() {
        return srcs;
      },
      add_source_without_node: function(src) {
        // console.log src
        if (src.docid === null || src.docid === void 0) {
          return;
        }
        if (!srcs.hasOwnProperty(src.docid)) {
          srcs[src.docid] = {};
        }
        if (src.node) {
          srcs[src.docid][src.node] = src;
        } else {
          console.log('error');
        }
        if (first_src === null) {
          return first_src = src;
        }
      },
      // if debug is true
      //     console.log srcs

      //function that calls show source for the first source (without knowing what it is)
      show_first_source: function() {
        if (first_src !== null) {
          return this.show_source(first_src);
        }
      },
      get_doc: function(src) {
        var p, that;
        that = this;
        if (!sources[src.docid]) {
          p = this.get_doc_orig(src);
          if (ldc_annotate.get_source_transform() === true) {
            p = p.then(function(sorc) {
              if (src.type === 'ltf') {
                return that.handle_ltf(src, sorc);
              } else {
                return that.get_doc2(src, sorc);
              }
            });
          }
          sources[src.docid] = p;
        }
        return sources[src.docid];
      },
      //this function sends an ajax call to get a document that we don't already have stored on the client side
      get_doc_orig: function(src) {
        var display_id, obj, ref, that;
        if (debug === true) {
          console.log('get doc');
        }
        that = this;
        display_id = '#' + $('.current_display').attr('id');
        if (debug === true) {
          console.log(display_id);
        }
        if (src.type === 'text' && src.hasOwnProperty('id')) {
          return get(`/sources/text?id=${src.id}`, function(data) {
            if (debug === true) {
              console.log(data);
              console.log('yy');
            }
            if (data.hasOwnProperty('document')) {
              data = data.document;
            }
            delete data.id;
            // sources[src.docid] = data
            if (debug) {
              console.log('sources[docid]');
              console.log(data);
            }
            that.set_current_display(display_id);
            // that.show_source src, data
            src;
            return data;
          });
        } else {
          if (src.docid) {
            obj = {};
            obj.transform = ldc_annotate.get_source_transform();
            obj.uid = src.docid;
            obj.type = (ref = src.type) != null ? ref : 'document';
            if (src.local) {
              obj.local = src.local;
            }
            obj.level = 1;
            obj.line_char_limit = line_char_limit;
            obj.task_id = src.task_id;
            if (!obj.task_id) {
              obj.task_id = $('.Root').data().obj.task_id;
            }
            if (debug === true) {
              console.log('GET');
              console.log(src);
              console.log(obj);
              console.log(display_id);
              obj.uget = 1;
            }
            // $('.current_display').html('retrieving document')
            // $.post('/sources/uget', obj, (data) ->
            return get(`//ldc-developers.s3.amazonaws.com/${src.docid}.xml.0.json`, function(data) {
              data.uid = obj.uid;
              delete data.id;
              if (debug === true) {
                console.log(data);
              }
              // sources[src.docid] = data
              if (debug) {
                console.log('sources[docid]');
                console.log(data);
              }
              that.set_current_display(display_id);
              // if obj.type is 'ltf'
              //     ltf = true
              //     that.show_source_ltf(src, data)
              // else
              //     that.show_source(src, data)
              src;
              return data;
            });
          } else {
            return Promise.resolve(null);
          }
        }
      },
      get_doc2: function(src, sorc) {
        var display_id, obj, that;
        if (debug === true) {
          console.log('get doc2');
        }
        that = this;
        display_id = '#' + $('.current_display').attr('id');
        if (debug === true) {
          console.log(display_id);
        }
        if (src.docid) {
          obj = {};
          obj.transform = true;
          obj.uid = src.docid;
          obj.type = 'document';
          if (src.local) {
            obj.local = src.local;
          }
          obj.level = 1;
          obj.line_char_limit = line_char_limit;
          obj.get_lines = 1;
          if (debug === true) {
            console.log('get2');
            obj.uget = 2;
          }
          return get(`//ldc-developers.s3.amazonaws.com/${src.docid}.xml.1.json`, function(data) {
            data.uid = obj.uid;
            delete data.id;
            if (debug === true) {
              console.log('uget last');
              console.log(data);
            }
            sorc.line_index = data.line_index;
            sorc.char_index = data.char_index;
            sorc.meta = data.meta;
            sorc.range = src.range;
            // that.set_current_display display_id
            // that.show_source(src, data)
            return sorc;
          });
        } else {
          return Promise.resolve(null);
        }
      },
      get_sentences: function(src) {
        var display_id, obj, that;
        if (debug === true) {
          console.log('get_sentences');
        }
        that = this;
        display_id = '#' + $('.current_display').attr('id');
        if (debug === true) {
          console.log(display_id);
        }
        if (src.docid) {
          obj = {};
          obj.transform = ldc_annotate.get_source_transform();
          obj.uid = src.docid;
          obj.type = src.type;
          obj.level = 1;
          obj.line_char_limit = line_char_limit;
          obj.get_lines = 2;
          obj.segmenter = ldc_annotate.get_sentence_segmenter();
          if (src.local === true) {
            obj.local = true;
          }
          if (debug === true) {
            console.log('get3');
          }
          return post('/sources/uget', obj, function(data) {
            data.uid = obj.uid;
            delete data.id;
            if (debug === true) {
              console.log(data);
            }
            return sources[src.docid].then(function(sorc) {
              sorc.sentence_index = data.line_index;
              sorc.char_sentence_index = data.char_index;
              console.log(sources);
              that.set_current_display(display_id);
              return that.show_source(src, data);
            });
          });
        }
      },
      //this function clears a display (TextSource widget)
      clear_display: function(display_selector) {
        return $(display_selector).html('');
      },
      //this function refreshes a display (TextSource widget)
      refresh_display: function(display) {
        var display_id, that;
        display_id = div2sel(display);
        that = this;
        return $(display_id).each(function() {
          var data, f, obj, uid;
          // that.clear_display(display_id);
          that.set_current_display(display_id);
          console.log('show14');
          data = $('.Root').data();
          obj = data.obj;
          if (obj && obj.source && obj.source.uid && !data.skip_refresh) {
            uid = obj.source.uid;
            that.show_source(obj.source);
          } else {
            that.show_source($(display_id).data().value);
          }
          that.select_text_by_chars_helper(display_id);
          f = $('.Root').data().display_show_last;
          if (f) {
            return f();
          }
        });
      },
      // Function appends image or video element to selector with class 'selectable_media'
      // @param {String} docid - media uid, ex. 'IC001K26V.jpg'
      // @param {Integer} type - 'image' or 'video'
      // @param {Integer} sel - select to which media should be attached
      // @param {Regex} pat - regex pattern for file name
      // @returns null - modifies the dom
      append_selectable_media_element: function(docid, type, sel, pat) {
        return this.append_media_element(docid, type, sel, pat, 'selectable_media');
      },
      // Function appends image or video element to selector
      // @param {String} docid - media uid, ex. 'IC001K26V.jpg'
      // @param {Integer} type - 'image' or 'video'
      // @param {Integer} sel - select to which media should be attached
      // @param {Regex} pat - regex pattern for file name
      // @param {String} classes - class names to indicate selectability or other, usually 'selectable_media'
      // @returns null - modifies the dom
      append_media_element: function(docid, type, sel, pat, classes) {
        var b, div_uid, path, uid;
        console.log(docid);
        path = `//ldc-developers.s3.amazonaws.com/${docid}`;
        if (docid.match(pat)) {
          uid = docid.match(pat)[1];
        } else {
          console.log('NO MATCH');
          console.log(docid);
          console.log(pat);
          return;
        }
        div_uid = uid; //.replace /\./g, '-'
        if (type === 'video') {
          b = ['video', 'src', path, 'controls', '', 'video here'];
        } else if (type === 'image') {
          b = ['img', 'src', path, 'alt', 'image here', ''];
        }
        return $(sel).append(ldc_nodes.array2html(['div', 'id', `node-${div_uid}`, 'class', 'selectable_media', [['div', 'class', 'media_uid', uid], ['div', 'class', 'media_container', [b]]]]));
      },
      append_media_element2: function(docid, type, sel, classes, url) {
        var b, div_uid, path, uid;
        console.log(docid);
        uid = docid;
        path = url;
        div_uid = docid; //.replace /\./g, '-'
        if (type === 'video') {
          b = ['video', 'src', path, 'controls', '', 'video here'];
        } else if (type === 'image') {
          b = ['img', 'src', path, 'alt', 'image here', ''];
        }
        return $(sel).append(ldc_nodes.array2html(['div', 'id', `node-${div_uid}`, 'class', 'selectable_media', [['div', 'class', 'media_uid', uid], ['div', 'class', 'media_container', [b]]]]));
      },
      rsd_helper2: function(rsd) {
        var m, uid;
        m = rsd.match(/(\w{9}).rsd.txt$/);
        uid = m ? m[1] : `${rsd}`;
        return uid;
      },
      rsd_helper1: function(rsd) {
        var div_uid, sel, that, uid;
        that = this;
        console.log(rsd);
        uid = that.rsd_helper2(rsd);
        div_uid = uid; //.replace /\./g, '\\.'
        $('.split-doc-view').prepend(`<div class='rsd Text Document selectable_media' id='node-${div_uid}'/>`);
        sel = `#node-${div_uid}`;
        // console.log sel
        // console.log $(sel).length
        $(sel).data().meta = {};
        $(sel).data().meta.id = uid;
        $(sel).data().value = {
          docid: div_uid
        };
        ldc_source.set_current_display(sel);
        return ldc_source.show_source({
          uid: uid,
          docid: uid,
          type: 'document',
          local: true
        });
      },
      
      // Appends all the media in data into a split view and full view display
      // @param {String} source - selector where to attach media elements (like '.SourceDoc')
      // @param {Object} data - object like {doctype: [paths, fileuids, etc], doctype2: [..., ...]}.
      //     internal pattern grabs the uids /(\w{9}(_\d+)?\.\w+)(?:\.\w+)?$/
      // returns null - modifies the dom
      append_all_media: function(source, data) {
        var doc, l, len, nodeid, pat, path, r, ref, res, root, rsd, that, uid;
        that = this;
        root = window.ldc;
        r = root.resources;
        res = data.files || data;
        if (res['scn.png']) {
          r.screenshot = res["scn.png"][0].split('/')[1];
        }
        $(source).html('');
        // $(source).append("<ul class='nav-tabs'>
        //   <li class='tab-header-and-content'>
        //     <a href='javascript:void(0)' class='tab-link is-active'>Split View</a>
        //     <div class='tab-content is-open split-doc-view' style='display: block;'>
        //     </div>
        //   </li>
        // </ul>")
        if (res['rsd.txt']) {
          console.log(res);
          ref = res["rsd.txt"];
          for (l = 0, len = ref.length; l < len; l++) {
            rsd = ref[l];
            that.rsd_helper1(rsd);
          }
        }
        pat = /(\w{9}(_\d+)?\.\w+)(?:\.\w+)?$/;
        that.prepare_img_vid_media_object(res, pat, function(uid, type) {
          // ldc_source.append_selectable_media_element uid, type, '.split-doc-view', pat
          return ldc_source.append_selectable_media_element(uid, type, source, pat);
        });
        if (res.recon) {
          $('.Root').append("<div class='full-doc-view'> <div class='full-doc-view__header'> <div class='full-doc-view__title'> Full Doc View </div> <div class='full-doc-view__collapse'> Hide </div> </div>");
          // $('a:contains("Full View")').click()
          $('.full-doc-view').draggable({
            handle: ".full-doc-view__header"
          });
          if (Array.isArray(res["recon"])) {
            uid = res["recon"][0];
          } else {
            uid = res["recon"];
          }
          path = `/sources/media?uid=${uid}`;
          nodeid = `node-${uid}`;
          $('.full-doc-view').append(`<iframe src='${path}' class='iframedoc' id='${nodeid}'></iframe>`);
          $('.full-doc-view__collapse').on('click', function(e) {
            var fdv, iframedoc;
            fdv = $('.full-doc-view');
            iframedoc = $('.iframedoc');
            if (iframedoc.hasClass('collapsed')) {
              iframedoc.show();
              iframedoc.removeClass('collapsed');
              $('.full-doc-view__collapse').html('Hide');
              return fdv.height('600');
            } else {
              iframedoc.hide();
              iframedoc.addClass('collapsed');
              fdv.height('2em');
              return $('.full-doc-view__collapse').html('Show');
            }
          });
          doc = document.getElementById(nodeid);
          $(doc).on('load', function() {
            var a, b;
            a = doc.contentDocument;
            b = $(a).find('.selectable_media');
            $(a).find('body').on('click', function(e) {
              var curElement, i, offset, q, ref1, ref2, results, t, y, ypercent;
              selected_text = a.getSelection().toString();
              // get offset of iframe body, iframe body height, get % of the way down that 
              offset = $(a).find('body').offset();
              y = e.pageY - offset.top;
              ypercent = Math.abs(y / a.body.scrollHeight);
              $('a:contains("Split View")').click();
              $('.rsd').click();
              document.querySelector(".rsd").scrollIntoView();
              if ($('.Left').length > 0) {
                $('.Left')[0].scrollTop = $('.rsd').height() * ypercent;
              } else {
                console.log("should be scrolling");
                $('.SourceDoc')[0].scrollTop = $('.rsd').height() * ypercent;
              }
              // find span with first char of selected text, followed by span with following char, etc
              // then set their background color and class
              // on click, unset color and class
              if (selected_text) {
                curElement = $('.rsd').find(`span:contains('${selected_text[0]}')`);
                for (i = q = 1, ref1 = selected_text.length - 1; (1 <= ref1 ? q <= ref1 : q >= ref1); i = 1 <= ref1 ? ++q : --q) {
                  curElement = curElement.next(`span:contains('${selected_text[i]}')`);
                }
                if (curElement.length > 0) {
                  curElement.css('background-color', 'red');
                  curElement.addClass('selectedfv');
                  results = [];
                  for (i = t = 1, ref2 = selected_text.length - 1; (1 <= ref2 ? t <= ref2 : t >= ref2); i = 1 <= ref2 ? ++t : --t) {
                    curElement = curElement.prev("span");
                    curElement.css('background-color', 'red');
                    results.push(curElement.addClass('selectedfv'));
                  }
                  return results;
                }
              }
            });
            return $(b).on('click', function(e) {
              var target_node_id;
              console.log('handling img click');
              target_node_id = "node-" + $(this).attr('src').split('=')[1];
              $('a:contains("Split View")').click();
              console.log(target_node_id);
              document.getElementById(target_node_id).scrollIntoView();
              $('#' + target_node_id.replace('.', '\\.')).click();
              return e.stopPropagation();
            });
          });
          return $('body').on('click', function(e) {
            if (!$(e.target).closest('.full-doc-view').length) {
              $('.selectedfv').css('background-color', '');
              return $('.selectedfv').removeClass('selectedfv');
            }
          });
        }
      },
      open_screenshot: function() {
        var uid, url;
        uid = $('.Root').data().resources.screenshot;
        if (uid) {
          url = `/sources/media?uid=${uid}`;
          return window.open(url, "_blank", 'location,status,scrollbars,resizable,width=800, height=800');
        } else {
          return alert('no screenshot found');
        }
      },
      open_live_web_version: function() {
        var url;
        url = $('.Root').data().resources.manifest.data.url;
        if (url) {
          return window.open(url, "_blank");
        } else {
          return alert('no url found');
        }
      },
      // helper function handles varying formats of manifest "files" for media
      // @param {Object} res - manifest "files" object
      // @param {Regex} pat - uid pattern, usually /(\w{9}(_\d+)?\.\w+)(?:\.\w+)?$/
      // @param {Function} f - function that gets called with each object, usually 
      //     ldc_source.append_selectable_media_element uid, type, '.split-doc-view', pat
      // @returns null - usually modifies the dom
      prepare_img_vid_media_object: function(res, pat, f) {
        var image, images, img_ary, m, results, type, uid, uids;
        uids = [];
        images = {
          "jpg": res['jpg'],
          "gif": res['gif'],
          "png": res['png'],
          "bmp": res['bmp']
        };
        images['mp4'] = res.mp4;
        results = [];
        for (type in images) {
          img_ary = images[type];
          if (img_ary != null) {
            results.push((function() {
              var l, len, results1;
              results1 = [];
              for (l = 0, len = img_ary.length; l < len; l++) {
                image = img_ary[l];
                m = image.match(pat);
                uid = m ? m[1] : `${image}.${type}`;
                if (type === 'mp4') {
                  results1.push(f(uid, 'video'));
                } else {
                  results1.push(f(uid, 'image'));
                }
              }
              return results1;
            })());
          } else {
            results.push(void 0);
          }
        }
        return results;
      },
      //this is the main function used when displaying a new document in the text source
      // src is a Text.  put the parent Text into the current_display
      show_source: function(src, data) {
        var that;
        that = this;
        if (ltf) {
          src.type = 'ltf';
        }
        if (src.type === 'ltf') {
          ltf = true;
          return this.show_source_ltf(src, data);
        } else {
          return that.show_source_helper(src, data);
        }
      },
      show_source_display_document: function(current_display_value, src, sorc, current_display_id) {
        var current_docid, local_line_char_limit, that, workflow;
        that = this;
        local_line_char_limit = line_char_limit;
        if (src.docid.match(/^CMN/) || src.docid.match(/cmn$/)) {
          $('.Root').addClass('no_underline_space');
        }
        if (src.docid.match(/^CMN/) || src.docid.match(/cmn$/)) {
          local_line_char_limit = 38;
        }
        if (src.docid.match(/^AMH/) || src.docid.match(/amh$/)) {
          local_line_char_limit = 48;
        }
        //document already displayed in this pane
        // current_docid = null
        // return if current_docid is src.docid and current_docid is current_display_value.docid
        workflow = ldc_annotate_get_workflow();
        if (debug === true) {
          console.log('here4');
        }
        //sourceDocMap[current_display] = if data then data else src
        // that.clear_display '.current_display'

        // add rawtext to the data node
        current_display_value.rawtext = sorc.string;
        //if source transform mode is on
        if (current_display_value.hasOwnProperty('transform')) {
          ldc_annotate.set_source_transform(current_display_value.transform);
        }
        current_display_value.docid = src.docid;
        if (ldc_annotate.get_source_transform() === true) {
          // if src.type is 'ltf'
          //     that.handle_ltf src, local_line_char_limit, sorc
          //     # that.show_source_ltf src, data
          that.handle_lines2(src, sorc);
          that.handle_lines(src, current_display_id, sorc);
        } else {
          //for additional markup which is specified on a per-workflow basis
          if (workflow.hasOwnProperty('display_document')) {
            workflow['display_document'](sorc, src.node, src);
          } else {
            if (sorc.string) {
              $('.current_display').html(sorc.string);
            } else {
              $('.current_display').html(sorc.orig);
            }
          }
        }
        current_src = src;
        current_docid = current_display_value.docid;
        if (workflow.hasOwnProperty('display_actions')) {
          workflow['display_actions'](sorc, src.pane);
        }
        if (debug === true) {
          console.log('here3');
        }
        if (ldc_nodes.get_constraint('rtl')) {
          $('.Document').css('direction', 'rtl');
          return $('.Document span').each(function(i, x) {
            if ($(x).text().match(/\d+-/)) {
              return $(x).css('direction', 'ltr').css('unicode-bidi', 'bidi-override');
            }
          });
        }
      },
      show_source_helper: function(src, data) {
        var current_display_id, current_display_value, d1, that, workflow;
        that = this;
        if (debug) {
          console.log('showing');
        }
        if (debug) {
          d1 = new Date();
        }
        if ($('.current_display').length === 0) {
          console.error(`couldn't find current_display for ${$('.Root').data().obj._id}`);
        }
        current_display_value = $('.current_display').data().value;
        current_display_id = $('.current_display').attr('id');
        if (debug) {
          console.log(`showing ${current_display_id}`);
        }
        workflow = ldc_annotate_get_workflow();
        if (workflow.hasOwnProperty('searchToTextSourceMap') && src.pane) {
          this.set_current_display(workflow['searchToTextSourceMap'](src.pane));
        }
        if (src.id && !src.docid) {
          src.docid = src.id;
        }
        return that.get_doc(src).then(function(sorc) {
          var d2;
          that.show_source_display_document(current_display_value, src, sorc, current_display_id);
          if ($('.Root').hasClass('full')) {
            ldc_source.mark_posts();
          }
          if (debug === true) {
            return d2 = new Date();
          }
        });
      },
      // console.log "show source: took #{d2.getTime() - d1.getTime()} ms"
      handle_lines: function(src, current_display_id, sorc) {
        var that;
        that = this;
        if (debug === true) {
          console.log('here5');
        }
        if (!$('.current_display').hasClass('added_all_lines')) {
          this.add_all_lines(src.docid, current_display_id, sorc);
          $('.current_display').addClass('added_all_lines');
        }
        if (ldc_annotate.workflow.after_add_all_lines) {
          // $('.current_display .underlines').remove()
          ldc_annotate.workflow.after_add_all_lines();
        }
        if (debug === true) {
          console.log('here6');
        }
        if (!(ldc_nodes.get_constraint('hide_underlines') || $('.current_display .underlines').length !== 0)) {
          this.add_all_underlines(src.docid, sorc);
        }
        if (debug === true) {
          console.log('here7');
        }
        if (ldc_annotate.get_source_sentence_transform() === true) {
          if (sorc.sentence_index) {
            $.each(sorc.sentence_index, function(i, indices) {
              var j, l, ref, ref1, results;
              results = [];
              for (j = l = ref = indices[0], ref1 = indices[1] + 1; (ref <= ref1 ? l < ref1 : l > ref1); j = ref <= ref1 ? ++l : --l) {
                results.push($(`#${current_display_id}-char-${j}`).addClass(`sentence-${i}`));
              }
              return results;
            });
          } else {
            this.get_sentences(src);
          }
        }
        if (src.beg) {
          window.location.hash = `#${current_display_id}-char-${src.beg}`;
        }
        if (sorc.hack) {
          return $('.current_display').append(sorc.hack.replace(/\n/g, "<br/>"));
        }
      },
      handle_lines2: function(src, srcc) {
        var r1, r2;
        r2 = srcc.range2;
        if (srcc.range) {
          srcc.range_as_string = srcc.range.split(':');
          srcc.range_as_int = [parseInt(srcc.range_as_string[0]), parseInt(srcc.range_as_string[1])];
          r1 = srcc.range_as_int;
          if (r2) {
            if (r2[0] > r1[0] && r2[0] <= r1[1]) {
              r1[0] = r2[0];
            }
            if (r2[1] < r1[1] && r2[1] >= r1[0]) {
              return r1[1] = r2[1];
            }
          }
        } else {
          srcc.range_as_int = 1;
          if (r2) {
            return srcc.range_as_int = r2;
          }
        }
      },
      show_source_ltf: function(src, data) {
        var obj, that;
        that = this;
        if (src.psm === true) {
          obj = {
            uid: src.id,
            task_id: src.task_id,
            type: 'psm',
            transform: false,
            level: 1
          };
          return post('/sources/uget', obj, function(d) {
            psm = $.parseXML(d.string);
            return that.show_source_helper(src, data);
          });
        } else {
          // that.show_source_helper src, data
          return this.show_source_helper(src, data);
        }
      },
      // that.show_source_helper src, data
      // show_source_ltf2: (src, data) ->
      //     ldc_nodes.wait_for ".current_display", ->
      //         show_source_ltf3 src, data
      show_source_ltf2: function(src, data) {
        var current_display_id, current_display_value, d1, d2, local_line_char_limit, p, that, workflow;
        that = this;
        if (debug) {
          console.log('showing');
        }
        if (debug) {
          d1 = new Date();
        }
        current_display_value = $('.current_display').data().value;
        current_display_id = $('.current_display').attr('id');
        if (debug) {
          console.log(`showing ${current_display_id}`);
        }
        workflow = ldc_annotate_get_workflow();
        if (workflow.hasOwnProperty('searchToTextSourceMap') && src.pane) {
          this.set_current_display(workflow['searchToTextSourceMap'](src.pane));
        }
        if (src.id && !src.docid) {
          src.docid = src.id;
        }
        local_line_char_limit = line_char_limit;
        if (src.docid.match(/^CMN/) || src.docid.match(/cmn$/)) {
          $('.Root').addClass('no_underline_space');
        }
        if (src.docid.match(/^CMN/) || src.docid.match(/cmn$/)) {
          local_line_char_limit = 38;
        }
        if (src.docid.match(/^AMH/) || src.docid.match(/amh$/)) {
          local_line_char_limit = 48;
        }
        if (sources.hasOwnProperty(src.docid)) {
          sources[src.docid].then(function(sorc) {
            var current_docid;
            // alert(ldc_annotate.get_source_transform())
            if (debug === true) {
              console.log('source');
              console.log(sources);
            }
            if (current_docid === src.docid && current_docid === current_display_value.docid) {

            } else {
              if (debug === true) {
                //document already displayed in this pane
                console.log('here4');
              }
              //sourceDocMap[current_display] = if data then data else src
              this.clear_display('.current_display');
              // add rawtext to the data node
              current_display_value.rawtext = sorc.string;
              //if source transform mode is on
              if (current_display_value.hasOwnProperty('transform')) {
                ldc_annotate.set_source_transform(current_display_value.transform);
              }
              current_display_value.docid = src.docid;
              if (ldc_annotate.get_source_transform() === true) {
                if (sorc.line_index) {
                  that.handle_lines2(src, sorc);
                  that.handle_lines(src, current_display_id, sorc);
                } else {
                  that.handle_ltf(src, local_line_char_limit);
                  that.show_source_ltf(src, data);
                }
              } else {
                //for additional markup which is specified on a per-workflow basis
                if (workflow.hasOwnProperty('display_document')) {
                  workflow['display_document'](sorc, src.node, src);
                } else {
                  if (sorc.string) {
                    $('.current_display').html(sorc.string);
                  } else {
                    $('.current_display').html(sorc.orig);
                  }
                }
              }
            }
            if (debug === true) {
              console.log('here2');
            }
            current_src = src;
            current_docid = current_display_value.docid;
            if (workflow.hasOwnProperty('display_actions')) {
              workflow['display_actions'](sorc, src.pane);
              true;
            }
            if (debug === true) {
              return console.log('here3');
            }
          });
        } else {
          // alert(ldc_annotate.get_source_transform())
          p = this.get_doc(src);
        }
        // alert(ldc_annotate.get_source_transform())
        if (ldc_nodes.get_constraint('rtl')) {
          $('.Document').css('direction', 'rtl');
          $('.Document span').each(function(i, x) {
            if ($(x).text().match(/\d+-/)) {
              return $(x).css('direction', 'ltr').css('unicode-bidi', 'bidi-override');
            }
          });
        }
        if (debug === true) {
          d2 = new Date();
          console.log(`show source: took ${d2.getTime() - d1.getTime()} ms`);
        }
        return p;
      },
      handle_ltf: function(src, sorc) {
        var char_index, doc, i, lastsegi, line_bchar, line_btoken, line_index, line_index_segments, local_line_char_limit, paragraphi, paragraphs, paragraphs_to_lines, segment_lines, segments, start_char, that, token_chars, tokens, x;
        that = this;
        local_line_char_limit = line_char_limit;
        if (src.docid.match(/^CMN/) || src.docid.match(/cmn$/)) {
          $('.Root').addClass('no_underline_space');
        }
        if (src.docid.match(/^CMN/) || src.docid.match(/cmn$/)) {
          local_line_char_limit = 38;
        }
        if (src.docid.match(/^AMH/) || src.docid.match(/amh$/)) {
          local_line_char_limit = 48;
        }
        segment_lines = $('.Root').data().obj.segment_lines || ldc_nodes.get_constraint('segment_lines');
        // this.get_doc2 src
        doc = $.parseXML(sorc.orig);
        // console.log doc
        line_index = [null];
        line_index_segments = [null];
        paragraphs_to_lines = [[1, 1]];
        char_index = [];
        tokens = [];
        // console.log doc
        start_char = -1;
        x = $(doc).find('TOKEN').first();
        line_bchar = null; //parseInt $(x).attr('start_char')
        line_btoken = 0;
        token_chars = [];
        i = -1;
        segments = [];
        lastsegi = -1;
        paragraphs = []; //[ [ 0, '' ] ]
        paragraphi = 0;
        if (psm) {
          sorc.psm = psm;
          that.parse_paragraphs(src);
          paragraphs = sorc.paragraphs;
        }
        $(doc).find('SEG').each(function(segi, seg) {
          var segstart;
          lastsegi = segi;
          segstart = i + 1;
          $(seg).find('TOKEN').each(function(tokeni, x) {
            var pcheck, token_bchar, token_echar;
            // console.log x
            i += 1;
            token_bchar = parseInt($(x).attr('start_char'));
            token_echar = parseInt($(x).attr('end_char'));
            token_chars.push([token_bchar, token_echar]);
            if (line_bchar === null) {
              line_bchar = token_bchar;
            }
            if (paragraphs[paragraphi] && token_bchar >= paragraphs[paragraphi][0]) {
              pcheck = true;
              paragraphs_to_lines[paragraphi][1] = line_index.length;
              paragraphs_to_lines.push([line_index.length + 1, line_index.length + 1]);
              paragraphi += 1;
            } else {
              pcheck = false;
            }
            if (token_echar - line_bchar > local_line_char_limit || $(x).text().match(/^[\u25cf\u25aa]/) || pcheck) {
              // console.log "pushing #{x} #{tokeni}"
              // console.log $(x).text()
              line_index.push([line_btoken, i - 1]);
              line_index_segments.push(segi);
              line_bchar = token_bchar;
              line_btoken = i;
            }
            char_index.push([line_index.length, i - line_btoken]);
            tokens.push($(x).text());
            if (line_btoken === i && token_bchar === token_echar && i > 0 && token_bchar - 1 === token_chars[token_chars.length - 2][1] && line_index.length > 0) {
              line_index[line_index.length - 1][1] = i;
              line_btoken += 1;
              char_index[char_index.length - 1][0] -= 1;
              char_index[char_index.length - 1][1] = char_index[char_index.length - 2][1] + 1;
              return line_bchar = null;
            }
          });
          segments.push([segstart, i]);
          if (segment_lines === true) {
            line_index.push([line_btoken, i]);
            line_index_segments.push(segi);
            line_bchar = null;
            return line_btoken = i + 1;
          }
        });
        if (segment_lines !== true) {
          if (line_bchar !== null) {
            line_index.push([line_btoken, line_btoken + char_index[char_index.length - 1][1]]);
          }
          line_index_segments.push(lastsegi);
        } else {
          $.each(line_index_segments, function(i, x) {
            var seg;
            if (i > 0) {
              seg = segments[x];
              if (seg.length === 2) {
                seg.push(i);
                return seg.push(i);
              } else {
                return seg[3] = i;
              }
            }
          });
        }
        // console.log "pushing final #{aa} #{bb}"
        // $('.current_display').append $(x).text()
        sorc.line_index = line_index;
        sorc.line_index_segments = line_index_segments;
        sorc.char_index = char_index;
        sorc.tokens = tokens;
        sorc.token_chars = token_chars;
        sorc.segments = segments;
        paragraphs_to_lines[paragraphs_to_lines.length - 1][1] = line_index.length - 1;
        sorc.paragraphs_to_lines = paragraphs_to_lines;
        return sorc;
      },
      add_segment_index: function(uid) {
        console.log("HERE");
        console.log(uid);
        return sources[uid].then(function(sorc) {
          var b, i, index, l, ref, x;
          x = sorc.orig;
          b = null;
          index = [];
          for (i = l = 0, ref = x.length; (0 <= ref ? l <= ref : l >= ref); i = 0 <= ref ? ++l : --l) {
            if (x[i] === "\n") {
              if (b !== null) {
                index.push([b, i - 1]);
              }
              b = null;
            } else {
              if (b == null) {
                b = i;
              }
            }
          }
          return sorc.segments = index;
        });
      },
      parse_paragraphs: function(src) {
        var a;
        a = [];
        return sources[src.docid].then(function(sorc) {
          var b, doc;
          doc = sorc.psm;
          $(doc).find("string[type='p']").each(function(i, x) {
            var author, begin_offset;
            begin_offset = parseInt($(x).attr("begin_offset"));
            author = '';
            return a.push([begin_offset, author]);
          });
          b = a.sort(function(x, y) {
            return x[0] - y[0];
          });
          return sorc.paragraphs = b;
        });
      },
      get_post_author_offsets: function(doc) {
        var a;
        a = [];
        $(doc).find("string[type='post']").each(function(i, x) {
          var author, begin_offset, datetime, y;
          begin_offset = parseInt($(x).attr("begin_offset"));
          y = $(x).find("attribute[name='author']").first().attr('value');
          author = y ? y : '';
          y = $(x).find("attribute[name='datetime']").first().attr('value');
          datetime = y ? y : '';
          return a.push([begin_offset, author, datetime]);
        });
        return a;
      },
      add_post_authors: function(a, src) {
        var that;
        that = this;
        // doc = $.parseXML psm
        // a = that.get_post_author_offsets doc
        return sources[src.docid].then(function(sorc) {
          var b, token_chars, tokeni;
          token_chars = sorc.token_chars;
          if (token_chars) {
            b = a.sort(function(x, y) {
              return x[0] - y[0];
            });
            tokeni = 0;
            return $.each(b, function(i, x) {
              var sel, sep, sl;
              while (token_chars[tokeni][0] < x[0]) {
                tokeni += 1;
              }
              sl = $('.Document').attr('id');
              sel = `${sl}-char-${tokeni}`;
              sep = `${sel}-sep`;
              return that.add_post_author(sel, sep, x[1]);
            });
          } else {
            return $.each(a, function(i, x) {
              var sel, sep;
              sel = 'node-2-char-' + x[0];
              if ($(sel).length === 0) {
                sel = 'node-1-char-' + x[0];
              }
              sep = `${sel}-sep`;
              return that.add_post_author(sel, sep, x[1], x[2]);
            });
          }
        });
      },
      add_post_author: function(sel, sep, author, datetime) {
        if ($(`#${sep}`).length === 0) {
          return $(`#${sel}`).parent().prepend(ldc_nodes.array2html(['div', 'id', sep, 'class', "author", 'style', "font-size:large; background-color:yellow", `===============${author},${datetime}===============`]));
        }
      },
      mark_posts: function() {
        var obj, src, that;
        that = this;
        src = $('.Root').data().obj.source;
        if (src && src.docid && sources[src.docid]) {
          if (window.authors) {
            return that.add_post_authors(window.authors, src);
          } else {
            obj = {};
            obj.uid = src.docid;
            obj.type = 'psm';
            obj.transform = false;
            obj.level = 1;
            return $.post('/sources/uget', obj, function(data) {
              var doc;
              window.psm = data.string;
              doc = $.parseXML(window.psm);
              window.authors = that.get_post_author_offsets(doc);
              return that.mark_posts(src);
            }, 'json');
          }
        } else {
          return setTimeout(function() {
            return that.mark_posts();
          }, 1000);
        }
      },
      mark_pss: function(src) {
        var doc, obj;
        if (src.docid) {
          obj = {};
          obj.uid = src.docid;
          obj.type = 'psm';
          obj.transform = false;
          obj.level = 1;
          $('.Document .author').remove();
          if (window.psm) {
            doc = $.parseXML(window.psm);
            return $(doc).find("string[type='post']").each(function(i, x) {
              var author, begin_offset;
              begin_offset = $(x).attr("begin_offset");
              author = $(x).find("attribute[name='author']").first().attr("value");
              return $('#node-2-char-' + begin_offset).parent().prepend('<div class="author" style="font-size:large; background-color:yellow">' + "===============" + author + "===============" + "</div>");
            });
          } else {
            return $.post('/sources/uget', obj, function(data) {
              return setTimeout(function() {
                var a, b, tokeni;
                window.psm = data.string;
                doc = $.parseXML(window.psm);
                a = [];
                console.log(data);
                $(doc).find("string[type='p']").each(function(i, x) {
                  var author, begin_offset;
                  begin_offset = parseInt($(x).attr("begin_offset"));
                  author = '';
                  return a.push([begin_offset, author]);
                });
                b = a.sort(function(x, y) {
                  return x[0] - y[0];
                });
                tokeni = 0;
                return sources[src.docid].then(function(sorc) {
                  var token_chars;
                  token_chars = sorc.token_chars;
                  $.each(b, function(i, x) {
                    var sel, sep;
                    while (token_chars[tokeni][0] < x[0]) {
                      tokeni += 1;
                    }
                    sel = `node-2-char-${tokeni}`;
                    sep = `${sel}-sep`;
                    if ($(`#${sep}`).length === 0) {
                      // $("##{sel}").prepend ldc_nodes.array2html [ 'hr', 'id', sep, '' ]
                      return $(`#${sel}`).prepend(`</p><p id=\"${sep}\">`);
                    }
                  });
                  return ldc_annotate.open_separate_document_window2('.Document');
                });
              }, 2000);
            }, 'json');
          }
        }
      },
      open_separate_document_window3: function(sel, underlines) {
        var a, separate_document_window;
        separate_document_window = window.open('', "webann_document_window", "toolbar=no,menubar=no,status=no,width=750,height=500");
        $('.Root').data().separate_document_window = separate_document_window;
        separate_document_window.document.open();
        a = $(sel).html();
        if (underlines) {
          a = a.replace(/(width|x)="(\d+)/g, function(x) {
            var i, y;
            y = x.split('"');
            i = Math.round(parseInt(y[1]) * .75);
            return `${y[0]}\"${i}`;
          });
        } else {
          a = a.replace(/(width|height)="(\d+)/g, function(x) {
            var y;
            y = x.split('"');
            return `${y[0]}\"0`;
          });
        }
        separate_document_window.document.write(ldc_nodes.array2html(['div', 'class', 'selected_frame', a]));
        return separate_document_window.document.close();
      },
      set_segment: function(n) {
        var data, obj, uid;
        data = $('.Root').data();
        obj = data.obj;
        uid = obj.source.uid;
        return sources[uid].then(function(sorc) {
          var seg;
          seg = sorc.segments[n];
          return sorc.range2 = [seg[2], seg[3]];
        });
      },
      // segments_ready: ->
      //     data = $('.Root').data()
      //     obj = data.obj
      //     uid = obj.source.uid
      //     # current_display_id = $('.current_display').attr('id')
      //     # prefix = "##{current_display_id}-line-"
      //     if sources[uid]
      //         if sources[uid].segments
      //             true
      //         else
      //             false
      //     else
      //         false
      next_segment: function(next) {
        var data, obj, that, uid;
        that = this;
        // $('.current_segment').removeClass 'current_segment'
        data = $('.Root').data();
        obj = data.obj;
        uid = obj.source.uid;
        // current_display_id = $('.current_display').attr('id')
        // prefix = "##{current_display_id}-line-"
        return sources[uid].then(function(sorc) {
          var ii, seg, segments;
          segments = sorc.segments;
          if (data.segment_i === void 0) {
            ii = 0;
          } else {
            // seg = segments[data.segment_i]
            // this.character_helper prefix, seg[2], seg[3], 'display', 'none'
            // x = segments[0][2]
            // y = segments[segments.length-1][3]
            // this.character_helper prefix, x, y, 'display', 'none'
            if (next === true) {
              ii = data.segment_i + 1;
            } else {
              ii = data.segment_i - 1;
            }
          }
          if (ii === segments.length) {
            ii -= 1;
          }
          if (ii === -1) {
            ii = 0;
          }
          seg = segments[ii];
          // this.character_helper prefix, seg[2], seg[3], 'display', 'inline'
          data.segment_i = ii;
          sorc.range2 = [seg[0], seg[1]];
          that.show_source(obj.source);
          console.log('source');
          console.log(obj.source);
          return ii;
        });
      },
      show_chars: function(x, y) {
        var i, l, ref, ref1, results;
        results = [];
        for (i = l = ref = seg[0], ref1 = seg[1] + 1; (ref <= ref1 ? l < ref1 : l > ref1); i = ref <= ref1 ? ++l : --l) {
          results.push($(`#${current_display_id}-char-${i}`).show());
        }
        return results;
      },
      find_quotes: function() {
        var obj, that;
        that = this;
        obj = $('.Root').data().obj.source;
        return setTimeout(function() {
          if (obj && sources[obj.uid]) {
            return sources[obj.uid].then(function(sorc) {
              var i, l, orig, quote, quotes, ref, results;
              if (sorc.orig) {
                console.log('quoting');
                console.log(obj);
                orig = sorc.orig;
                sorc.quotes = [];
                quotes = sorc.quotes;
                quote = 0;
                results = [];
                for (i = l = 0, ref = orig.length; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
                  if (orig.charAt(i) === '<') {
                    if (orig.substring(i, i + 6) === '<quote') {
                      quote += 1;
                    }
                  }
                  quotes.push(quote);
                  if (orig.charAt(i) === '>') {
                    if (orig.substring(i - 7, i + 1) === '</quote>') {
                      results.push(quote -= 1);
                    } else {
                      results.push(void 0);
                    }
                  } else {
                    results.push(void 0);
                  }
                }
                return results;
              } else {
                return that.find_quotes(obj);
              }
            });
          } else {
            return that.find_quotes(obj);
          }
        }, 1000);
      },
      color_quotes: function(obj, color) {
        var that;
        that = this;
        return setTimeout(function() {
          return sources[obj.uid].then(function(sorc) {
            var quotes;
            quotes = sorc.quotes;
            if (quotes) {
              return $.each(quotes, function(i, x) {
                if (x > 0) {
                  return $(`#node-2-char-${i}`).css('background-color', color);
                }
              });
            } else {
              return that.color_quotes(obj, color);
            }
          });
        }, 1000);
      },
      tokenize: function(obj, token_class) {
        var text, that;
        that = this;
        text = '';
        if ($(obj).text().match(/\S/)) {
          $.each($(obj).text().match(/(\S+)/g), function(i, x) {
            return text += '<span class="' + token_class + '" id="' + 'token-' + i + '">' + x + '</span> ';
          });
        }
        return $(obj).html(text);
      },
      //adds all the lines and characters in the document into the div_id, with the appropriate markup
      add_all_lines: function(docid, div_id, data) {
        var add, divid, that;
        that = this;
        if (!data.line_index) {
          return;
        }
        $(`#${div_id}`).append(`<div class=\"docid\">${docid}</docid>`);
        data.lines = {}; //reset the lines hash
        divid = '#' + div_id;
        if (engine === 'engine3') {
          $(divid).html('<canvas id="' + div_id + '-canvas"></canvas>');
          $(divid + '-canvas').addClass('border-black');
        }
        //code to add all the lines for the conversation style documents, needs to loop through each message
        if (data.type === 'session') {
          $.each(data.messages, function(i, message) {
            var msg_source;
            messageIdIndexMap[message.id] = i;
            msg_source = message.content;
            return $.each(msg_source.line_index, function(line_num, indices) {
              return that.add_line(div_id, line_num, indices, data, message, message.id.toString());
            });
          });
        } else {
          //code to add all the lines for newswire style documents
          if (data.line_index) {
            // this.add_line_timeout data, 1, div_id
            if (data.range_as_int === 1) {
              $.each(data.line_index, function(line_num, indices) {
                return that.add_line(div_id, line_num, indices, data);
              });
            } else {
              add = false;
              $.each(data.line_index, function(line_num, indices) {
                if (add === false) {
                  if (indices && indices[1] >= data.range_as_int[0]) {
                    add = true;
                  }
                }
                if (add === true) {
                  if (indices && indices[0] > data.range_as_int[1]) {
                    add = null;
                  }
                }
                if (add === true) {
                  return that.add_line(div_id, line_num, indices, data);
                }
              });
            }
            if (data.paragraphs_to_lines) {
              $.each(data.paragraphs_to_lines, function(i, x) {
                var ii, l, ref, ref1, results;
                if (x) {
                  $(`#${div_id}`).append(`<div id=\"addedp-${i}\" class=\"addedp\"></div>`);
                  results = [];
                  for (ii = l = ref = x[0], ref1 = x[1]; (ref <= ref1 ? l <= ref1 : l >= ref1); ii = ref <= ref1 ? ++l : --l) {
                    results.push($(`#${div_id}-line-${ii}`).appendTo(`#addedp-${i}`));
                  }
                  return results;
                }
              });
            }
          }
        }
        if (force_font_size) {
          // console.log "move #node-2-line-#{ii} to #addedp-#{i}"
          return $('.line').css('font-size', force_font_size);
        }
      },
      add_line_timeout: function(data, i, div_id) {
        var that;
        that = this;
        return setTimeout(function() {
          if (data.line_index.hasOwnProperty(i)) {
            that.add_line(div_id, i, data.line_index[i], data);
            return that.add_line_timeout(data, i + 1, div_id);
          }
        }, 10);
      },
      convert_arabic_string_to_display_chars: function(arabic_string) {
        var arabic_display_array, char, char_post, char_pre, final, final_letters, i, initial, l, medial, ref;
        //initial, medial and final form for each arabic character
        initial = {};
        medial = {};
        final = {};
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        initial[""] = "";
        medial[""] = "";
        final[""] = "";
        // conditional forms
        initial[''] = '';
        medial[''] = '';
        final[''] = '';
        final[''] = '';
        final[''] = '';
        // chars always considered final letters
        final_letters = ["", "", "", "", "", "", "", "", ""];
        arabic_display_array = [];
        for (i = l = 0, ref = arabic_string.length; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
          char_pre = i > 0 ? arabic_string.charAt(i - 1) : null;
          char = arabic_string.charAt(i);
          char_post = i < arabic_string.length - 1 ? arabic_string.charAt(i + 1) : null;
          //non-arabic char
          if (!char.match(/[\u0600-\u06FF\u0750-\u077F]/) || typeof final[char] === 'undefined') {
            // if char.match(/[\u0600-\u06FF\u0750-\u077F]/) and typeof final[char] == 'undefined'
            // console.log 'undefined:'
            // console.log char
            arabic_display_array.push(char);
            continue;
          }
          // console.log char
          if (char_pre === '' && char === '') {
            // console.log '****'
            char = '';
          }
          // initial
          if (char_pre === null || !char_pre.match(/[\u0600-\u06FF\u0750-\u077F]/) || indexOf.call(final_letters, char_pre) >= 0) {
            // console.log initial[char]
            if (char === '') {
              arabic_display_array.push(char);
            } else if (char === '' && char_post === '') {
              // console.log '----'
              char = '';
              arabic_display_array.push(char);
            } else if (typeof initial[char] === 'undefined') {
              console.log('undefined initial char: ' + char);
              arabic_display_array.push(char);
            } else {
              arabic_display_array.push(initial[char]);
            }
          // medial
          } else if (char_pre !== null && char_pre.match(/[\u0600-\u06FF\u0750-\u077F]/) && char_post !== null && char_post.match(/[\u0600-\u06FF\u0750-\u077F]/)) {
            // console.log medial[char]
            if (char === '') {
              arabic_display_array.push(char);
            } else if (char === '' && char_post === '') {
              char = '';
              arabic_display_array.push(char);
            } else if (typeof medial[char] === 'undefined') {
              console.log('undefined medial char: ' + char);
              arabic_display_array.push(char);
            } else {
              arabic_display_array.push(medial[char]);
            }
          // final
          } else if (indexOf.call(final_letters, char) >= 0 || char_post === null || !char_post.match(/[\u0600-\u06FF\u0750-\u077F]/)) {
            // console.log final[char]
            if (char === '') {
              arabic_display_array.push(char);
            } else if (char === '' && char_post === '') {
              char = '';
              arabic_display_array.push(char);
            } else if (typeof final[char] === 'undefined') {
              console.log('undefined final char: ' + char);
              arabic_display_array.push(char);
            } else {
              arabic_display_array.push(final[char]);
            }
          } else {
            // isolated
            arabic_display_array.push(char);
          }
        }
        return arabic_display_array;
      },
      minidoc: function(selector) {
        var div_id, docid, node, that;
        that = this;
        node = $(selector).data();
        div_id = `node-${node.meta.id}`;
        // console.log $(x).find('.MentionHeadText').data().value
        // if $(selector).siblings(".specialline").length is 0
        //     $(selector).after("<div id=\"#{div_id}-line-1\" class=\"specialline\" tabindex=0></div>")
        //     console.log 2
        docid = node.value.docid;
        $('.specialline').data().line_id = `${div_id}-line-1`;
        if (sources[docid]) {
          return sources[docid].then(function(sorc) {
            var line_html;
            line_html = that.wrap_chars_in_spans(div_id, '', [node.value.beg, node.value.end], sorc);
            line_html = `<div>${line_html}</div>`;
            return $('.speciallinetext').html(line_html);
          });
        }
      },
      wrap_chars_in_spans: function(div_id, message_id, indices, msg_source) {
        var arabic_display_array, i, l, line_html, q, ref, ref1, ref2, ref3;
        if (ltf) {
          return this.wrap_chars_in_spans_ltf(div_id, message_id, indices, msg_source);
        } else {
          line_html = '';
          if (ldc_annotate.get_arabic_text()) {
            arabic_display_array = this.convert_arabic_string_to_display_chars(msg_source.orig);
            for (i = l = ref = indices[0], ref1 = indices[1] + 1; (ref <= ref1 ? l < ref1 : l > ref1); i = ref <= ref1 ? ++l : --l) {
              line_html += '<span id="' + div_id + message_id + '-char-' + i + '">' + arabic_display_array[i] + '</span>';
            }
          } else {
//for(var i=indices[0]; i<indices[1]+1; i++){
            for (i = q = ref2 = indices[0], ref3 = indices[1] + 1; (ref2 <= ref3 ? q < ref3 : q > ref3); i = ref2 <= ref3 ? ++q : --q) {
              line_html += '<span id="' + div_id + message_id + '-char-' + i + '">' + htmlEscape(msg_source.orig.charAt(i)) + '</span>';
            }
          }
          return line_html;
        }
      },
      wrap_chars_in_spans_ltf: function(div_id, message_id, indices, msg_source) {
        var arabic_display_array, i, l, line_html, ntoken, q, ref, ref1, ref2, ref3;
        line_html = '';
        if (ldc_annotate.get_arabic_text()) {
          arabic_display_array = this.convert_arabic_string_to_display_chars(msg_source.orig);
          for (i = l = ref = indices[0], ref1 = indices[1] + 1; (ref <= ref1 ? l < ref1 : l > ref1); i = ref <= ref1 ? ++l : --l) {
            line_html += '<span id="' + div_id + message_id + '-char-' + i + '">' + arabic_display_array[i] + '</span>';
          }
        } else {
//for(var i=indices[0]; i<indices[1]+1; i++){
          for (i = q = ref2 = indices[0], ref3 = indices[1] + 1; (ref2 <= ref3 ? q < ref3 : q > ref3); i = ref2 <= ref3 ? ++q : --q) {
            line_html += '<span id="' + div_id + message_id + '-char-' + i + '">' + htmlEscape(msg_source.tokens[i]) + '</span>';
            ntoken = msg_source.token_chars[i + 1];
            if (ntoken && ntoken[0] > msg_source.token_chars[i][1] + 1) {
              line_html += ' ';
            }
          }
        }
        // remove last space?
        return line_html;
      },
      //this function runs the code specific for each line, for conversation style and newswire style
      add_line: function(div_id, line_num, indices, data, message, message_num) {
        var i, indices_index, l, line_html, message_attr, message_id, msg_source, obj, q, ref, ref1, ref2, text_obj;
        //if there is a separate message source, use it instead of the data attribute
        msg_source = message ? message.content : data;
        message_id = message_num ? '-msg-' + message_num : '';
        message_attr = message_num ? 'message="' + message_num + '"' : '';
        //var title_attr = message ? 'title="start time:' + message.start_date + ' end time: ' + message.end_date + '"' : '';
        //alert(1);
        //gather up all the characters in the selected formatting
        if (line_num !== 0) {
          if (indices === null) {
            line_html = '';
          } else {
            if (engine === 'engine1') {
              line_html = htmlEscape(msg_source.orig.substring(indices[0], indices[1] + 1));
            } else if (engine === 'engine2') {
              line_html = msg_source.orig.substring(indices[0], indices[1] + 1);
            } else if (engine === 'engine4') {
              line_html = '';
              if (indices.length === 2) {
                line_html += this.wrap_chars_in_spans(div_id, message_id, indices, msg_source);
              } else {
                //for the scenario where there are gaps in the display-able text in the middle of the line
                console.log('999999');
                //we are expecting an even length array of indices, don't bother displaying if we don't get that
                if (indices.length % 2 === 0) {
//for(var indices_index = 0; indices_index < indices.length; indices_index += 2){
//for(var i=indices[indices_index]; i<indices[indices_index+1]+1; i++){
                  for (indices_index = l = 0, ref = indices.length; l < ref; indices_index = l += 2) {
                    for (i = q = ref1 = indices[indices_index], ref2 = indices[indices_index + 1] + 1; (ref1 <= ref2 ? q < ref2 : q > ref2); i = ref1 <= ref2 ? ++q : --q) {
                      line_html += '<span id="' + div_id + message_id + '-char-' + i + '">' + htmlEscape(msg_source.orig.charAt(i)) + '</span>';
                    }
                  }
                }
              }
            }
          }
          //create an object for the line number and store it for later use
          obj = {
            line_id: div_id + message_id + '-line-' + line_num,
            underlines_id: div_id + message_id + '-underlines-' + line_num,
            srcs: [],
            underlines_height: 0,
            underlines_width: 0,
            message_id: message_num
          };
          if (data.type === 'session') {
            if (!data.lines.hasOwnProperty(message_num)) {
              data.lines[message_num] = {};
            }
            data.lines[message_num][line_num] = obj;
          } else {
            data.lines[line_num] = obj;
          }
          //add the line
          if (engine === 'engine1' || engine === 'engine4') {
            return $('#' + div_id).append('<div id="' + obj.line_id + '" class="line"' + message_attr + '>' + line_html + '</div>');
          } else if (engine === 'engine2') {
            $('#' + div_id).append('<canvas id="' + obj.line_id + '" class="line"></canvas>');
            text_obj = {
              layer: true,
              fillStyle: "#000",
              font: "12pt Courier",
              text: line_html,
              click: function(layer) {
                return alert(layer);
              }
            };
            text_obj = $('#' + obj.line_id).measureText(text_obj);
            text_obj.x = text_obj.width / 2;
            text_obj.y = text_obj.height / 2;
            return $('#' + obj.line_id).drawText(text_obj);
          }
        }
      },
      //this function adds all the underlines for a document/div(TextSource widget) combo
      add_all_underlines: function(docid, data) {
        var that;
        that = this;
        if (!data.hasOwnProperty('lines')) {
          return;
        }
        if (debug === true) {
          console.log('srcs');
          console.log(docid);
          console.log(srcs[docid]);
          console.log(data);
        }
        if (srcs[docid]) {
          switch (data.type) {
            case 'session':
              //cycle through all the text nodes with annotations in this document
              $.each(Object.keys(srcs[docid]), function(i, src) {
                return that.add_underlines(srcs[docid][src], data);
              });
              return $.each(data.messages, function(index, message) {
                var message_num, msg_source;
                msg_source = message.content;
                message_num = message.id;
                return $.each(msg_source.line_index, function(i, line) {
                  var line_obj;
                  //cycle through all lines and draw the underlines for that line
                  if (i !== 0) {
                    line_obj = data.lines[message_num][i];
                    if (line_obj.srcs.length > 0) {
                      return that.draw_underlines(data, line_obj);
                    }
                  }
                });
              });
            default:
              //cycle through all the text nodes with annotations in this document
              $.each(Object.keys(srcs[docid]), function(i, src) {
                return that.add_underlines(srcs[docid][src], data);
              });
              return that.draw_underlines_timeout(data, 1);
          }
        }
      },
      // add_all_underlines_ltf: (docid) ->
      //     that = this
      //     data = sources[docid]
      //     if not data.hasOwnProperty('lines')
      //         return
      //     if debug is true
      //         console.log 'srcs'
      //         console.log srcs[docid]
      //     if srcs[docid]
      //         switch data.type
      //             when 'session'
      //                 #cycle through all the text nodes with annotations in this document
      //                 $.each Object.keys(srcs[docid]), (i, src) ->
      //                     that.add_underlines(srcs[docid][src])

      //                 $.each data.messages, (index, message) ->
      //                     msg_source = message.content;
      //                     message_num = message.id;
      //                     $.each msg_source.line_index, (i, line) ->
      //                         #cycle through all lines and draw the underlines for that line
      //                         if i isnt 0
      //                             line_obj = data.lines[message_num][i]
      //                             if line_obj.srcs.length > 0
      //                                that.draw_underlines(data, line_obj);
      //             else
      //                 #cycle through all the text nodes with annotations in this document
      //                 $.each Object.keys(srcs[docid]), (i, src) ->
      //                     that.add_underlines(srcs[docid][src])

      //                 that.draw_underlines_timeout data, 1
      draw_underlines_timeout: function(data, i) {
        var line_obj, that;
        that = this;
        //cycle through all lines and draw the underlines for that line
        if (data.line_index.hasOwnProperty(i)) {
          if (data.lines.hasOwnProperty(i)) {
            line_obj = data.lines[i];
            if (line_obj.srcs.length > 0) {
              that.draw_underlines(data, line_obj);
              if (debug === true) {
                console.log('draw');
                console.log(data);
                console.log(line_obj);
              }
            }
          }
          return that.draw_underlines_timeout(data, i + 1);
        }
      },
      find_srcs_within_range: function(srcs, b, e) {
        var ssrcs;
        ssrcs = [];
        $.each(srcs, function(k, src) {
          if (src.end >= b && src.beg <= e) {
            return ssrcs.push(src);
          }
        });
        return ssrcs;
      },
      //this function takes a text node
      add_underlines: function(orig, data) {
        var char_index, line_srcs, lines, ssrcs, that;
        that = this;
        if (debug) {
          console.log('under1');
          console.log(orig);
        }
        //split so we can create different underlines if an annotation crosses multiple lines
        ssrcs = this.divide_source(orig, data);
        char_index = data.type === 'session' ? data.messages[messageIdIndexMap[orig.message_id]].content.char_index : data.char_index;
        lines = [];
        line_srcs = [];
        $.each(ssrcs, function(i, src) {
          var linen;
          if (char_index[src.beg]) {
            linen = char_index[src.beg][0];
            if (linen > 0 && data.lines[linen]) {
              lines.push(linen);
              return line_srcs = data.type === 'session' ? line_srcs.concat(data.lines[orig.message_id][linen].srcs) : line_srcs.concat(data.lines[linen].srcs);
            }
          }
        });
        //if this annotation overlaps with any other annotation, increase its level until it is on its own line
        orig.level = 0;
        while (that.collides_set(orig, line_srcs)) {
          orig.level += 1;
        }
        //add the srcs to the srcs for the line number
        $.each(ssrcs, function(i, src) {
          var all, linen, ref, x;
          linen = lines[i];
          if (linen > 0) {
            src.level = orig.level;
            src.node = orig.node;
            all = data.lines[linen].srcs;
            if (ref = src.node, indexOf.call((function() {
              var l, len, results;
              results = [];
              for (l = 0, len = all.length; l < len; l++) {
                x = all[l];
                results.push(x.node);
              }
              return results;
            })(), ref) < 0) {
              return all.push(src);
            }
          }
        });
        orig.lines = lines;
        return lines;
      },
      collides2: function(src1, src2) {
        if (src1.end < src2.beg) {
          return false;
        }
        if (src2.end < src1.beg) {
          return false;
        }
        return true;
      },
      collides_set2: function(src1, srcs) {
        var i, l, ref;
        for (i = l = 0, ref = srcs.length; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
          if (this.collides2(src1, srcs[i])) {
            collision = srcs[i];
            return true;
          }
        }
        return false;
      },
      collides_with_line: function(i, src, sorc) {
        var s, seg;
        seg = sorc.segments[i];
        s = {
          beg: seg[0],
          end: seg[1]
        };
        // console.log 'collides'
        // console.log i
        // console.log s
        // console.log src
        // console.log sources[uid].segments
        if (src.beg === void 0 || src.beg === null) {
          return false;
        }
        return this.collides2(src, s);
      },
      draw_underlines: function(data, line_obj) {
        if (ldc_nodes.get_constraint('nu')) {
          return this.draw_underlines2(data, line_obj);
        } else {
          return this.draw_underlines1(data, line_obj);
        }
      },
      //this function draws the underlines for a given line
      draw_underlines2: function(data, line_obj) {
        var char_index, display_id, i, l, max_level, ref, s, space, that;
        if (debug) {
          console.log("DRAWING");
        }
        that = this;
        char_index = data.type === 'session' ? data.messages[messageIdIndexMap[parseInt(line_obj.message_id)]].content.char_index : data.char_index;
        max_level = 0;
        $.each(line_obj.srcs, function(src_i, src) {
          if (src.level > max_level) {
            return max_level = src.level;
          }
        });
        display_id = '#node-' + line_obj.line_id.split('-')[1];
        //calculate the height based on the maximum level, width based on the line width
        // line_obj.underlines_height = (max_level + 1) * ( underline_height * 2 + 1 )
        line_obj.underlines_height = (max_level + 1) * (underline_height + 5 + 1);
        //line_obj.underlines_width = $('.current_display')[0].scrollWidth;
        line_obj.underlines_width = $(display_id)[0].scrollWidth;
        if ($(`#${line_obj.underlines_id}`).length > 0) {
          return;
        }
        space = !$('.Root').hasClass('no_underline_space');
        for (i = l = ref = max_level; (ref <= 0 ? l <= 0 : l >= 0); i = ref <= 0 ? ++l : --l) {
          $('#' + line_obj.line_id).after(ldc_nodes.array2html(['div', 'id', `${line_obj.underlines_id}-${i}`, 'class', "underlines", '']));
          s = '';
          $(`#${line_obj.line_id} span`).each(function(ii, x) {
            s += ldc_nodes.array2html(['span', 'id', `${$(x).attr('id')}-underline-${i}`, 'class', 'char-underline', $(x).text()]);
            if (space) {
              return s += ldc_nodes.array2html(['span', 'id', `${$(x).attr('id')}-underline-${i}-space`, 'class', 'char-underline', ' ']);
            }
          });
          $(`#${line_obj.underlines_id}-${i}`).append(s);
        }
        //cycle through the sources for this line, compute the width and offset, and draw the underline
        return $.each(line_obj.srcs, function(i, src) {
          var leftn, linen, offset, orig, stringWidth;
          if (char_index[src.beg]) {
            orig = data.type === 'session' ? data.messages[messageIdIndexMap[parseInt(line_obj.message_id)]].content.orig : data.orig;
            leftn = char_index[src.beg][1];
            linen = char_index[src.beg][0];
            // if ltf
            //     stringWidth = that.get_width_ltf(src.beg, src.end, display_id, data, false)
            // else
            //     stringWidth = that.get_width(orig.substring(src.beg, src.end+1), display_id)
            // offset = 0
            // if leftn > 0
            //     if ltf
            //         offset = that.get_width_ltf(src.beg-leftn, src.beg-1, display_id, data, true)
            //     else
            //         offset = that.get_width(orig.substring(src.beg-leftn, src.beg), display_id)
            offset = null;
            stringWidth = null;
            return that.draw_underline2(offset, stringWidth, src.level, `#${line_obj.underlines_id}`, src, display_id);
          }
        });
      },
      draw_underlines1: function(data, line_obj) {
        var a, b, char_index, display_id, max_level, that;
        // console.log "DRAWING"
        that = this;
        char_index = data.type === 'session' ? data.messages[messageIdIndexMap[parseInt(line_obj.message_id)]].content.char_index : data.char_index;
        max_level = 0;
        $.each(line_obj.srcs, function(src_i, src) {
          if (src.level > max_level) {
            return max_level = src.level;
          }
        });
        display_id = '#node-' + line_obj.line_id.split('-')[1];
        //calculate the height based on the maximum level, width based on the line width
        // line_obj.underlines_height = (max_level + 1) * ( underline_height * 2 + 1 )
        line_obj.underlines_height = (max_level + 1) * (underline_height + 5 + 1);
        //line_obj.underlines_width = $('.current_display')[0].scrollWidth;
        line_obj.underlines_width = $(display_id)[0].scrollWidth;
        $(`#${line_obj.underlines_id}`).remove();
        b = [];
        a = ['svg', 'xmlns', "http://www.w3.org/2000/svg", 'id', line_obj.underlines_id, 'class', 'underlines', 'height', line_obj.underlines_height, 'width', line_obj.underlines_width, b];
        $.each(line_obj.srcs, function(i, src) {
          var leftn, linen, offset, orig, stringWidth;
          if (char_index[src.beg]) {
            orig = data.orig;
            leftn = char_index[src.beg][1];
            linen = char_index[src.beg][0];
            if (ltf) {
              stringWidth = that.get_width_ltf(src.beg, src.end, display_id, data, false);
            } else {
              stringWidth = that.get_width(src.beg, src.end + 1, display_id);
            }
            offset = 0;
            if (leftn > 0) {
              if (ltf) {
                offset = that.get_width_ltf(src.beg - leftn, src.beg - 1, display_id, data, true);
              } else {
                offset = that.get_width(src.beg - leftn, src.beg, display_id);
              }
            }
            return b.push(that.draw_underline(offset, stringWidth, src.level, `#${line_obj.underlines_id}`, src.node));
          }
        });
        if (debug) {
          console.log(a);
        }
        $('#' + line_obj.line_id).append(array2html(a));
        return $('#' + line_obj.line_id + ' svg').before('<div/>');
      },
      draw_underline2: function(offset, width, depth, selector, src, display_id) {
        var i, id_prefix, l, node, node_id, q, ref, ref1, ref2, ref3, results, sel, space, textnode_value, textsource_id, underline_color, underline_info, workflow;
        node_id = src.node;
        workflow = ldc_annotate_get_workflow();
        underline_color = 'blue';
        node = $('#node-' + node_id).data();
        if (!node) {
          return;
        }
        if (node && node.value && node.value.color) {
          // console.log "drawing #{node_id}"
          underline_color = node.value.color;
        }
        // if (workflow.hasOwnProperty('get_underline_info')) {
        if (false) {
          underline_info = workflow['get_underline_info'](node_id);
          underline_color = underline_info.color;
          if (underline_info.tooltip.length > 0) {
            textnode_value = ldc_annotate.get_node(underline_info.text_id).value;
            textsource_id = workflow['getActiveTextSource']();
            id_prefix = textsource_id + '-char-';
            for (i = l = ref = textnode_value.beg, ref1 = textnode_value.end; (ref <= ref1 ? l < ref1 : l > ref1); i = ref <= ref1 ? ++l : --l) {
              $(id_prefix + i).attr('title', underline_info.tooltip);
            }
          }
        }
        space = !$('.Root').hasClass('no_underline_space');
        results = [];
        for (i = q = ref2 = src.beg, ref3 = src.end; (ref2 <= ref3 ? q <= ref3 : q >= ref3); i = ref2 <= ref3 ? ++q : --q) {
          sel = `${display_id}-char-${i}-underline-${src.level}`;
          $(sel).addClass(underline_color);
          $(sel).data().name = node_id;
          if (space && i + 1 <= src.end) {
            sel = `${display_id}-char-${i}-underline-${src.level}-space`;
            $(sel).addClass(underline_color);
            results.push($(sel).data().name = node_id);
          } else {
            results.push(void 0);
          }
        }
        return results;
      },
      // * if an annotation crosses multiple line breaks, this function returns an array of sources that don't cross lines,
      // * otherwise it returns an array with the source
      divide_source: function(src, data) {
        var beg, character_line, current_display_id, current_line, end, i, id_prefix, orig, ssrcs;
        // need to check for integers here to avoid infinite loop
        beg = parseInt(src.beg);
        end = parseInt(src.end);
        ssrcs = [];
        orig = data.type === 'session' ? data.messages[messageIdIndexMap[src.message_id]].content.orig : data.orig;
        if (ltf === false) {
          //adjust begin/end offsets if they are line breaks
          while (orig.charAt(beg) === "\n") {
            beg += 1;
          }
          while (orig.charAt(end) === "\n") {
            end -= 1;
          }
        }
        //find the id prefix for this annotation and set the current_line
        current_display_id = $('.current_display').attr('id');
        id_prefix = data.type === 'session' ? `#${current_display_id}-msg-${src.message_id}-char-` : `#${current_display_id}-char-`;
        current_line = $(id_prefix + beg).parent().attr('id');
        i = beg;
        while (i < end) {
          i += 1;
          character_line = $(id_prefix + i).parent().attr('id');
          if ((ltf === false && orig.charAt(i) === "\n") || current_line !== character_line) {
            ssrcs.push({
              docid: src.docid,
              beg: beg,
              end: i - 1
            });
            if (ltf === false) {
              while (orig.charAt(i) === "\n") {
                i += 1;
              }
            }
            beg = i;
            current_line = character_line;
            if (current_line === void 0) {
              current_line = $(id_prefix + i).parent().attr('id');
            }
          }
        }
        //add the last source (or only source if no line breaks)
        ssrcs.push({
          docid: src.docid,
          beg: beg,
          end: end
        });
        return ssrcs;
      },
      get_width: function(x, y, display_id) {
        var i, l, ref, ref1, sum;
        sum = 0;
        for (i = l = ref = x, ref1 = y - 1; (ref <= ref1 ? l <= ref1 : l >= ref1); i = ref <= ref1 ? ++l : --l) {
          sum += $(`${display_id}-char-${i}`).width();
        }
        return sum;
      },
      get_width_ltf: function(b, e, display_id, data, add_space) {
        var i, l, ref, ref1, space_length, sum;
        space_length = 5;
        // $("#{display_id}").append('<span id="extra_space"> </span>')
        // space_length = $("#extra_space").width()
        // $("#extra_space").remove()
        sum = 0;
        for (i = l = ref = b, ref1 = e; (ref <= ref1 ? l <= ref1 : l >= ref1); i = ref <= ref1 ? ++l : --l) {
          sum += $(`${display_id}-char-${i}`).width();
          if (i < e && data.token_chars[i + 1][0] > data.token_chars[i][1] + 1) {
            sum += space_length;
          }
        }
        if (add_space === true && data.token_chars[e + 1][0] > data.token_chars[e][1] + 1) {
          sum += space_length;
        }
        return sum;
      },
      
      ///
      //* function that sends a post to retrieve the document being clicked on, and to display/format it in the TextSource pane, specifically for the search prototype
      ///
      display_searched_document: function(docid, terms) {
        return $.post('/sources/get_text', {
          docid: docid
        }, function(data) {
          var display;
          display = $('.TextSource');
          display.html(data.orig);
          display.find('post').addClass('border-bottom-black').each(function() {
            return $(this).prepend('<author>' + $(this).attr('author') + '</author><br>');
          });
          display.find('headline, author').addClass('border-bottom-black bold');
          display.find('post quote').addClass('quote');
          return display.html(terms.reduce(function(text, term) {
            return text.replace(new RegExp(term, 'ig'), '<span style="background-color: yellow;">' + term + '</span>');
          }, display.html()));
        }, "json");
      },
      annotate_into_new_listitem_standard: function(new_text_node_value, list, text) {
        ldc_annotate.unselect_text(ldc_annotate.get_curtextsource());
        ldc_annotate.add_list_item_to_list(`.${list}`);
        return ldc_annotate.add_message(`new.${text}`, 'change', new_text_node_value);
      }
    };
  })();

}).call(this);
