// Generated by CoffeeScript 2.6.1
var Waveform, help_screen, help_screen2, imported_keys, j, jsons, len, len1, p, ref, ref1, settings, x;
import { set_urls } from './aws_helper'
import { update_segments } from './segments_helper'
import { active_docid, active_channel } from './stores'
import { times, set_times, selection } from './times'
import { get_audio_buffer_info_for_waveform } from '../audio/buffer'

import {
  WaveformHelper
} from '../waveform/waveform_helper';

import BrowseB from '../work/browse_b.svelte';

import {
  IbmTranscript
} from '../waveform/ibm_transcript';

// settings = require('./settings.html.haml');

// import settings_css from '../work/settings.scss';

import {
  Channel
} from './channel';

// import css from './waveform.scss';

import { Keyboard } from '../work/keyboard';

import Modal from '../modal.svelte'

help_screen = {};

ref = ['waveform', 'input', 'playback', 'services', 'files'];
for (j = 0, len = ref.length; j < len; j++) {
  x = ref[j];
  // help_screen[x] = require(`./help_screen_${x}.md`);
  help_screen[x] = '';
}

help_screen2 = {};

ref1 = ['main'];
for (p = 0, len1 = ref1.length; p < len1; p++) {
  x = ref1[p];
  help_screen2[x] = true;
}

imported_keys = {};



import {
  x as keys_help_screen_files
} from './keys_help_screen_files';

imported_keys.keys_help_screen_files = keys_help_screen_files;

import {
  x as keys_waveform
} from './keys_waveform';

keys_waveform.beg = keys_waveform.selection;

keys_waveform.end = keys_waveform.selection;

imported_keys.keys_waveform = keys_waveform;

import {
  x as keys_input
} from './keys_input';

imported_keys.keys_input = keys_input;

import {
  x as keys_playback
} from './keys_playback';

imported_keys.keys_playback = keys_playback;


import {
  SpeechRecognition
} from './speechtotext.js';

jsons = function(obj) {
  return JSON.stringify(obj);
};

Waveform = class Waveform {
  // create is like a constructor, creating a waveform object with default
  // values for attributes and functions/methods.  It does very little besides
  // returning an object.  Calling init on that object is also like a constructor
  // doing more significant setup work.  Using a ruby analogy, create is like 
  // new and init is like initialize, but init has to be called explicitly.
  constructor(_interface) {
    this.interface = _interface;
    this.helper = new WaveformHelper(this);
    // $('body').prepend helpx
    this.debug = false; // turns on extra console.log statments
    this.external = false;
    this.node = this.interface;
    this.name = this.node.meta.id;
    this.selector = `#node-${this.node.meta.id}`;
    this.wave_selection_offset = null; // for current selection
    this.wave_selection_length = 0; // for current selection
    this.wave_selection_end = null; // for current selection, needed for the way change is detected
    this.wave_display_length = null; // seconds, for waveform display
    this.wave_display_offset = null; // seconds, for waveform display
    this.wave_display_length_in_samples = null;
    this.wave_display_offset_in_samples = null;
    this.samples_per_pixel = null;
    this.wave_canvas_width = null; // pixels
    this.play_head = 0;
    this.playheads = new Map();
    this.wave_offset_pixels = false;
    this.mousemove_x = false;
    this.mousedown = false;
    this.mousedown_x = false;
    this.mouseup_x = false;
    this.big_step = 50;
    this.little_step = 10;
    this.step1 = 0;
    this.step2 = 0;
    this.step3 = 0;
    this.step4 = 0;
    // wave_end_pixels   = false
    this.wave_adjust_btime = false;
    this.wave_adjust_etime = false;
    this.wave_adjust_time = false;
    this.wave_adjust_scroll = false; // update waveform based on scrolling on mouse move
    this.wave_autoscroll = false;
    this.wave_autoscrollb = false;
    this.wave_autoscrolle = false;
    this.wave_scale = null; // wave_canvas_length / wave_canvas_width (seconds per pixel)
    // @active_channel = 0
    this.transcript_line_selector = null;
    this.wave_active_transcript_line = false;
    this.stereo = null;
    // @channels = []
    this.cache = {};
    this.cache2 = {};
    this.update_cursor = false;
    this.update_handles = false;
    this.update_play_head = false;
    this.split_line_margin = 0.1;
    this.mode = 'cursor';
    this.keyboards = {};
    this.special = false;
    this.sources = window.sources_object; //new Sources 'waveform', this
    this.speechrecognition = false;
    this.wave_audio = {};
  }

  round_to_1_place(num) {
    return Math.round(num * 10) / 10;
  }

  round_to_2_places(num) {
    return Math.round(num * 100) / 100;
  }

  round_to_3_places(num) {
    return Math.round(num * 1000) / 1000;
  }

  round_to_6_places(num) {
    return Math.round(num * 1000000) / 1000000;
  }

  convert_seconds_to_samples(seconds) {
    return Math.floor(seconds * this.wave_buffer_sample_rate);
  }

  convert_samples_to_seconds(samples) {
    return samples / this.wave_buffer_sample_rate;
  }

  convert_seconds_to_pixels(seconds) {
    return seconds / this.wave_scale;
  }

  convert_pixels_to_seconds(pixels) {
    return pixels * this.wave_scale;
  }

  init() {
    var aa, bb, h, l, that, vars, w, wh;
    w = this;
    that = this;
    l = 10; // length in seconds
    wh = 125; // height in pixels
    // w.services = ldc_nodes.getp_simple('https://webann.ldc.upenn.edu').then (data) ->
    w.services = ldc_services.init();
    w.help_screens();
    // ldc_nodes.wait_for_root_key "add_from_waveform_list", ->
    // root = $('.Root').data()
    vars = window.ldc.vars;
    aa = `.${vars.add_from_waveform_list}`;
    bb = `new.${vars.add_from_waveform_audio}`;
    w.add_transcript_line_based_on_selection = w.get_add_transcript_line(aa, bb, 'selection');
    w.add_transcript_line_based_on_play_head = w.get_add_transcript_line(aa, bb, 'play_head');
    w.add_transcript_line_split = w.get_add_transcript_line(aa, bb, 'split');
    w.transcript_line_selector = `.${vars.add_from_waveform_list}Item`;
    w.transcript_line_selector = ".segment";
    // $('.Root').on 'click', '.DeleteButton', ->
    //     n = $(this).parents(s2).attr('id').replace('node-', '')
    //     ldc_annotate.add_message n, 'delete', null
    //     ldc_annotate.submit_form()
    // active_docid.subscribe( (x) => {
    //   if(x != w.docid){
    //     w.docid = x;
    //     if(x.match(/_A\.wav/)) w.docid2 = x.replace(/_A/g, '_B');
    //     w.wave_audio.id = x;
    //     // btime: @node.value.beg
    //     // etime: @node.value.end
    //     w.wave_docid = x;
    //     // window.ldc.vars.wave_docid = x;
    //     get_audio_buffer_info_for_waveform(w);
    //   }
    // } );
    // that.wave_buffer = w.node.buffer
    // wave_buffers[nid] = b
    // stereo = true if b.numberOfChannels > 1

    // if $('.Waveform').length is 2
    //     w.stereoa = $(w.selector).hasClass 'ChannelA'
    //     w.stereob = $(w.selector).hasClass 'ChannelB'
    // h = {
    //   name: 'delete_all_confirm_modal',
    //   delegate: that,
    //   b: 'DELETE',
    //   f: "delete_all",
    //   h: 'Delete ALL segments?'
    // };
    // that.delete_all_confirm_modal = new Modal(h);
    // that.delete_all_confirm_modal.init();
    // h = {
    //   name: 'delete_last_section_confirm_modal',
    //   delegate: that,
    //   b: 'DELETE',
    //   f: "delete_last_section",
    //   h: 'Delete last section?'
    // };
    // that.delete_last_section_confirm_modal = new Modal(h);
    // that.delete_last_section_confirm_modal.init();
    // h = {
    //   name: 'settings_modal',
    //   delegate: that,
    //   b: 'close',
    //   f: "close_modallll",
    //   h: 'Settings'
    // };
    // that.settings_modal = new Modal(h);
    // return that.settings_modal.init();
    w.set_wave_events2();
    w.set_wave_events3();
    times.subscribe( (x) => {
        w.wave_canvas_width = x.wave_canvas_width;
        w.wave_display_offset = x.wave_display_offset;
        w.wave_display_length = x.wave_display_length;
    } );
  //   mouse.subscribe( (x) => {
  //     let moved = w.mousemove_x == x.move_x;
  //     let down = w.mousedown_x == x.down_x;
  //     let up = w.mouseup_x == x.up_x;
  //     w.mousemove_x = x.move_x;
  //     w.mousedown_x = x.down_x;
  //     w.mouseup_x = x.up_x;
  //     if(moved && x.move_x) w.set_move_params();
  //     if(down && x.down_x) w.set_mousedown_true;
  //     if(up && x) w.set_mousedown_false;
  //   } );
  }


  // w.add_timit()
  // console.log 'aaa'


  speaker_test() {
    return console.log(ldc_nodes.get_node_class_by_name('Speaker').value);
  }

  // set_speaker() {
  //   return $('.crnt .Speaker').data().obj.set_speaker();
  // }

  help_screens() {
    var c, w;
    w = this;
    // $.each [ 'main', 'waveform', 'input', 'playback', 'edit', 'service' ], (i, hh) ->
    $.each(help_screen, function(x, v) {
      var delegate, kb, y;
      // this["help_screen_#{x}"] = help_screen[x]
      $.each(['', 'help_screen_'], function(i, y) {
        var kb, map;
        // this[z] = imported_keys[z]
        kb = new Keyboard(`${y}${x}`);
        w.keyboards[kb.name] = kb;
        map = imported_keys[`keys_${kb.name}`];
        if (map) {
          return kb.set_map(map);
        }
      });
      y = `help_screen_${x}`;
      kb = w.keyboards[y];
      delegate = x === 'edit' ? ldc_work.get_editor() : w;
      kb.set_delegate(delegate);
      if (x === 'playback') {
        w.keyboards.playback.set_delegate(delegate);
      }
      w[`show_${y}`] = function() {
        var h;
        h = {
          html: v,
          keyboard: kb,
          remove: true
        };
        return $('.ann_pane').data().help_screen.open(h);
      };
      return kb.unknown_key_callback = function() {
        return w.help_screen_message('unknown choice');
      };
    });
    return $.each(help_screen2, function(x, v) {
      var delegate, kb, y;
      // this["help_screen_#{x}"] = help_screen[x]
      $.each(['', 'help_screen_'], function(i, y) {
        var kb, map;
        // this[z] = imported_keys[z]
        kb = new Keyboard(`${y}${x}`);
        w.keyboards[kb.name] = kb;
        map = imported_keys[`keys_${kb.name}`];
        if (map) {
          return kb.set_map(map);
        }
      });
      y = `help_screen_${x}`;
      kb = w.keyboards[y];
      delegate = x === 'edit' ? ldc_work.get_editor() : w;
      kb.set_delegate(delegate);
      if (x === 'playback') {
        w.keyboards.playback.set_delegate(delegate);
      }
      w[`show_${y}`] = function() {
        return w.component.show_help_screen_main(kb);
      };
      return kb.unknown_key_callback = function() {
        return w.help_screen_message('unknown choice');
      };
    });
  }

  help_screen_message(m) {
    $('#help_screen_message').text(m);
    return setTimeout(function() {
      return $('#help_screen_message').text('');
    }, 5000);
  }

  // set_time_heights: (ticks, cursor) ->
  //     this.set_time_heights_helper ticks, cursor
  //     this.set_time_heights_helper ticks, cursor, waveform2 if stereo is true

    // wrapper for both channels
  update_channels() {
    var w;
    return w = this;
  }

  // this.update_channel update_waveform, waveform2, false, (active_channel is 1) if stereo is true
  cursor_x() {
    return this.mousemove_x || this.mousedown_x;
  }

  set_times_then_draw(x, y) {
    return set_times(this, x, y);
  }

  // draws a selection rectangle on a waveform, optionally with timestamps
  draw_scrollbar_rect(waveform) {}

  play_callback(node, playing) {
    var w;
    w = this;
    w.play_head = node.play_head;
    for( const [ k, v ] of w.playheads) v();
    if (playing) {
      if (w.play_head < w.wave_display_offset || w.play_head > w.wave_display_offset + w.wave_display_length) {
        w.set_times_then_draw(w.play_head, w.wave_display_length);
      }
      // selector = "#node-#{node.meta.id}-waveform-#{w.active_channel}"
      // selector += ' .waveform-svg'
      // console.log "NAN #{w.play_head} #{w.wave_display_offset}" if @debug
      w.update_play_head = true;
      if (w.set_playing_transcript_line_index) {
        return w.set_playing_transcript_line();
      }
    }
  }

  // w.draw_play_head selector, 0
  // w.draw_play_head selector.replace('0 ', '1 '), 1 if w.stereo
  // x = w.convert_seconds_to_pixels(w.play_head - w.wave_display_offset)
  // display = w.channels[0]
  // w.draw_waveform_line selector, x, 'play_head', 'green', true, display.time_height_cursor
  // display = w.channels[1]
  // w.draw_waveform_line selector, x, 'play_head', 'green', false, display.time_height_cursor

    // called continuously, see top of file
  waveform_callback(current_audio_node, playing) {
    var w;
    w = this;
    if (current_audio_node) {
      // return if w.drawing is true
      // w.drawing = true
      // console.log 'draw wave'
      // w.wave_scale = w.wave_display_length / w.wave_canvas_width
      w.play_callback(current_audio_node, playing);
    }
    // handles everything but the waveform itself
    // for x in w.channels
    //     x.update()
    // return unless w.component
    // w.component.update();
    w.update_cursor = false;
    w.update_scrollbar = false;
    w.update_underlines = false;
    w.update_play_head = false;
    w.update_ticks = false;
    w.update_tick_times = false;
  }

  // w.drawing = false
  activate(docid) {
    if(docid && docid != this.wave_docid){
      // active_docid.update( () => docid );
      active_channel.update( () => docid == this.docid ? 0 : 1 );
      // activate3();
    }
  }

  keyboard_focus(e) {
    e.preventDefault();
    return $('.keyboard').focus();
  }

  open_spectrogram() {
    var w;
    w = this;
    w.spectrogram_flag = !w.spectrogram_flag;
    if (w.spectrogram_flag) {
      $('.spectrogram-canvas').show();
      return w.draw_spectrogram();
    } else {
      return $('.spectrogram-canvas').hide();
    }
  }

  // keep center point the same, but toggle between step size of .5s and .2s
  toggle_zoom() {
    var c, w, ww, z;
    w = this;
    w.zoom = !w.zoom;
    if (w.zoom) {
      z = 0.005;
    } else {
      z = 0.0125;
    }
    if (w.wave_selection_offset) {
      c = w.wave_selection_offset + w.wave_selection_length / 2;
    } else {
      c = w.wave_display_offset + w.wave_display_length / 2;
    }
    ww = z * w.wave_canvas_width;
    return w.set_times_then_draw(c - ww / 2, ww);
  }

  zoom_in() {
    var q, w;
    w = this;
    q = w.wave_display_length / 4;
    if (w.wave_selection_offset) {
      return w.set_times_then_draw(w.wave_selection_offset + w.wave_selection_length / 2 - q, q * 2);
    } else {
      return w.set_times_then_draw(w.wave_display_offset + q, q * 2);
    }
  }

  zoom_out() {
    var w;
    w = this;
    if (w.wave_selection_offset) {
      return w.set_times_then_draw(w.wave_selection_offset + w.wave_selection_length / 2 - w.wave_display_length, w.wave_display_length * 2);
    } else {
      return w.set_times_then_draw(w.wave_display_offset - w.wave_display_length / 2, w.wave_display_length * 2);
    }
  }

  sort_then_split() {
    var w;
    w = this;
    w.sort_transcript_lines(true);
    return w.split_line($('.active-transcript-line').data().meta.id, ldc_annotate, wave, '.List', 'new.Snippet');
  }

  // alert 'splitting!'
  refresh_waveform() {
    // that.sort_transcript_lines(false)
    return $('.Waveform').each(function(i, x) {
      return $(x).data().waveform.update_waveform = true;
    });
  }

  sort_transcript_lines_forward() {
    return this.sort_transcript_lines(true);
  }

  delete_all() {
    $('.ListItem').each(function(i, x) {
      return ldc_annotate.add_message($(x).data().meta.id, 'delete', null);
    });
    ldc_annotate.submit_form();
    ldc_annotate.add_callback( () => update_segments() );
  }

  delete_all_sections() {
    $('.SectionListItem').each(function(i, x) {
      return ldc_annotate.add_message($(x).data().meta.id, 'delete', null);
    });
    ldc_annotate.submit_form();
    ldc_annotate.add_callback( () => update_segments() );
  }

  delete_last_section() {
    var last;
    last = null;
    $('.SectionListItem').each(function(i, x) {
      var id;
      id = $(x).data().meta.id;
      if (Number(id) > Number(last)) {
        return last = id;
      }
    });
    if (last) {
      ldc_annotate.add_message(last, 'delete', null);
      ldc_annotate.submit_form();
      ldc_annotate.add_callback( () => update_segments() );
    }
  }

  delete_last_section_confirm() {
    return this.delete_last_section_confirm_modal.open_modal();
  }

  delete_current_section() {
    var id, last, that;
    that = this;
    last = null;
    id = $('.crnt').data().meta.id;
    if (id) {
      $('.SectionListItem').each(function(i, x) {
        var iid;
        iid = $(x).data().meta.id;
        if ($(x).find('.BegSeg').data().value.value === id || $(x).find('.EndSeg').data().value.value === id) {
          return last = iid;
        }
      });
      if (last) {
        return that.delete_section(last);
      }
    }
  }

  find_current_section() {
    var id, last;
    last = null;
    id = $('.crnt').data().meta.id;
    if (id) {
      $('.SectionListItem').each(function(i, x) {
        var iid;
        iid = $(x).data().meta.id;
        if ($(x).find('.BegSeg').data().value.value === id || $(x).find('.EndSeg').data().value.value === id) {
          return last = iid;
        }
      });
    }
    return last;
  }

  delete_section_from_modal() {
    var id, that;
    that = this;
    alert('here');
    return;
    id = that.delete_section_confirm_modal.section_id;
    return that.delete_section(id);
  }

  delete_section_confirm() {
    var id, section, that;
    that = this;
    id = that.find_current_section();
    if (id) {
      section = $(`#node-${id}`).find(".Section").data().value.value;
      $('#delete_section_confirm_modal h3').text(`Delete section ${section}?`);
      that.delete_section_confirm_modal.section_id = id;
      return that.delete_section_confirm_modal.open_modal();
    }
  }

  delete_all_sections_confirm() {
    var that;
    that = this;
    $('#delete_section_confirm_modal h3').text("Delete all sections?");
    that.delete_section_confirm_modal.section_id = 'all';
    return that.delete_section_confirm_modal.open_modal();
  }

  show_sections() {
    var w;
    w = this;
    return w.interface.segments.open_sections();
  }

  create_test_segment() {
    var audio_path, list_selector, span;
    list_selector = '.SegmentList';
    audio_path = 'new.Segment';
    span = {
      offset: 1.0,
      length: 1.0
    };
    this.add_audio_to_list(list_selector, audio_path, span);
    ldc_annotate.submit_form();
    ldc_annotate.add_callback( () => update_segments() );
  }

  move_cursor_left_big(e) {
    return this.move_cursor_helper(e, this.big_step, -1);
  }

  move_cursor_right_big(e) {
    return this.move_cursor_helper(e, this.big_step, 1);
  }

  move_cursor_left_little(e) {
    return this.move_cursor_helper(e, this.little_step, -1);
  }

  move_cursor_right_little(e) {
    return this.move_cursor_helper(e, this.little_step, 1);
  }

  set_mode_to_cursor() {
    return this.set_mode('cursor');
  }

  set_mode_to_window() {
    return this.set_mode('window');
  }

  set_mode_to_begx() {
    var w;
    w = this;
    w.mousedown_x = w.cursor_x();
    return w.set_mode('selection');
  }

  set_mode_to_beg() {
    return this.set_mode('beg');
  }

  set_mode_to_end() {
    return this.set_mode('end');
  }

  set_mode(x) {
    var w;
    w = this;
    if (x === w.mode) {
      return;
    }
    if (w.mode === 'beg' || w.mode === 'end') {
      w.mouseup_x = w.mousemove_x;
      w.set_mousedown_false();
    }
    w.mode = x;
    $('.mode').text(x);
    if (x === 'beg' || x === 'end') {
      if (w.wave_selection_offset === null) {
        w.set_current_selection(w.convert_pixels_to_seconds(w.mousemove_x), 0);
      }
      switch (x) {
        case 'beg':
          return w.set_mode_beg_end(w.convert_seconds_to_pixels(w.wave_selection_offset - w.wave_display_offset));
        case 'end':
          return w.set_mode_beg_end(w.convert_seconds_to_pixels(w.wave_selection_end - w.wave_display_offset));
      }
    }
  }

  set_mode_beg_end(x) {
    var w;
    w = this;
    w.mousemove_x = x;
    w.set_move_params();
    w.mousedown_x = x;
    return w.set_mousedown_true();
  }

  move_cursor_lstep1() {
    return this.move_cursor(this.step1, -1);
  }

  move_cursor_lstep2() {
    return this.move_cursor(this.step2, -1);
  }

  move_cursor_lstep3() {
    return this.move_cursor(this.step3, -1);
  }

  move_cursor_lstep4() {
    return this.move_cursor(this.step4, -1);
  }

  move_cursor_rstep1() {
    return this.move_cursor(this.step1, 1);
  }

  move_cursor_rstep2() {
    return this.move_cursor(this.step2, 1);
  }

  move_cursor_rstep3() {
    return this.move_cursor(this.step3, 1);
  }

  move_cursor_rstep4() {
    return this.move_cursor(this.step4, 1);
  }

  move_selection_lstep1() {
    return this.move_selection(this.step1, -1);
  }

  move_selection_lstep2() {
    return this.move_selection(this.step2, -1);
  }

  move_selection_lstep3() {
    return this.move_selection(this.step3, -1);
  }

  move_selection_lstep4() {
    return this.move_selection(this.step4, -1);
  }

  move_selection_rstep1() {
    return this.move_selection(this.step1, 1);
  }

  move_selection_rstep2() {
    return this.move_selection(this.step2, 1);
  }

  move_selection_rstep3() {
    return this.move_selection(this.step3, 1);
  }

  move_selection_rstep4() {
    return this.move_selection(this.step4, 1);
  }

  move_window_lstep1() {
    return this.move_window(this.step3, -1);
  }

  move_window_lstep2() {
    return this.move_window(this.wave_display_length, -0.5);
  }

  move_window_lstep3() {
    return this.move_window(this.wave_display_length, -1);
  }

  move_window_lstep4() {
    return this.move_window(this.wave_display_length, -2);
  }

  move_window_rstep1() {
    return this.move_window(this.step3, 1);
  }

  move_window_rstep2() {
    return this.move_window(this.wave_display_length, 0.5);
  }

  move_window_rstep3() {
    return this.move_window(this.wave_display_length, 1);
  }

  move_window_rstep4() {
    return this.move_window(this.wave_display_length, 2);
  }

  undo() {
    return this.component.undo();
  }

  move_cursor(x, factor) {
    var c, step, w;
    console.log('helping1');
    console.log(x);
    w = this;
    step = w.convert_seconds_to_pixels(x * factor);
    c = w.cursor_x();
    w.mousemove_x = c + step;
    w.set_move_params();
    selection.update( (x) => x );
  }

  move_selection(x, factor) {
    var c, step, w;
    console.log('helping2');
    console.log(x);
    w = this;
    step = w.convert_seconds_to_pixels(x * factor);
    c = w.cursor_x();
    w.set_mousedown_true();
    w.mousemove_x = c + step;
    w.set_move_params();
    selection.update( (x) => x );
  }

  move_window(x, factor) {
    var w;
    w = this;
    // set_times_then_draw protects against out of range
    return w.set_times_then_draw(w.wave_display_offset + (x * factor), w.wave_display_length);
  }

  split_segment_at_cursor() {
    var data, src, time, w;
    w = this;
    console.log(w.map);
    time = w.convert_pixels_to_seconds(w.cursor_x()) + w.wave_display_offset;
    if ($('.crnt').length === 1) {
      // id = $('.active-transcript-line').attr 'id'
      data = $(".crnt .Audio").data();
      src = data.value;
      if (time > src.beg && time < src.end) {
        src.end = w.round_to_3_places(time - w.split_line_margin);
        ldc_annotate.add_message(data.meta.id, 'change', src);
        return w.add_transcript_line_split();
      }
    }
  }

  merge_with_following_segment() {
    var data, id, ids, next_data, next_id, src, v1, v2, w;
    w = this;
    console.log(w.map);
    if (!w.segments) {
      w.segments = w.interface.segments;
    }
    ids = w.segments.find_active_id();
    if (ids.id && ids.next) {
      id = ids.id;
      next_id = ids.next;
      data = $(`#${w.map.get(id)} .Audio`).data();
      next_data = $(`#${w.map.get(next_id)} .Audio`).data();
      w.delete_transcript_line_based_on_segment_id(next_id, false);
      src = data.value;
      src.end = next_data.value.end;
      ldc_annotate.add_message(data.meta.id, 'change', src);
      data = $(`#${w.map.get(id)} .Transcription`).data();
      next_data = $(`#${w.map.get(next_id)} .Transcription`).data();
      v1 = data.value.value;
      v2 = next_data.value.value;
      if (v2 && v2.length > 0) {
        ldc_annotate.add_message(data.meta.id, 'change', {
          value: `${v1} ${v2}`
        });
      }
      $(`#node-${data.meta.id}`).addClass('refresh');
      ldc_annotate.submit_form();
      ldc_annotate.add_callback( () => update_segments() );
    }
  }

  play_current_span() {
    return this.component.play_current_span();
  }

  stop_playing() {
    return this.component.stop_playing();
  }

  set_wave_events2() {
    var that, w;
    w = this;
    that = w;
    $('body').on("direct-upload:end", function(e, data, status, xhr) {
      console.log(e);
      return $('.new_file_set').after(`<div class=uploaded>uploaded ${e.detail.file.name}</div>`);
    });
    $('body').on("direct-uploads:end", function(e, data, status, xhr) {
      console.log(e);
      $('.new_file_set').hide();
      return $('.new_file_set').after('<button class=file_upload_dismiss>Dismiss</button>');
    });
    $('body').on('click', '.file_upload_dismiss', function() {
      $('.new_source, .file_upload_dismiss, .uploaded').remove();
      return $('.Root').show();
    });
    return $('body').on("ajax:success", function(e, data, status, xhr) {
      console.log('TWO');
      console.log(e);
      if (e.detail[0].type === 'file_set') {
        return ldc_nodes.get(`/file_sets/${e.detail[0].id}`, function(data) {
          console.log('DATA');
          console.log(data);
          return $.each(data, function(i, x) {
            return w.add_timestamps(x);
          });
        });
      }
    });
  }

  set_wave_events3() {
    var f, scrollf, that, underline_callback, w;
    w = this;
    that = w;
    // $('.Root').on 'click', '.Segment', (e) ->
    //     return if wwaveform.display.disable_waveform is true
    //     node = $(this).parents('.Timestamps')[0]
    //     play_head = $(node).data().value.end
    //     that.show_node node, false
    //$('.Root').append ldc_nodes.waveform_controls(1)
    $('#button-add').on('click', function(e) {});
    $('#button-play').on('click', function(e) {
      return that.play_current_span();
    });
    $('#button-filter').on('click', function(e) {
      return that.filter();
    });
    $('#filter_modal_save').on('click', function() {
      return that.filter();
    });
    $(w.selector).on('mousemove', '.waveform-underlines', function(e) {
      return w.wave_adjust_scroll = false;
    });
    $(w.selector).on('mousemove', '.waveform-ticks', function(e) {
      return w.wave_adjust_scroll = false;
    });
    // this function wraps center_display_at_time, but determines the
    // location based on the scrollbar as a representation for the full file
    scrollf = function(x) {
      var max, min, noffset;
      noffset = w.round_to_3_places(x / w.wave_canvas_width * w.wave_audio.etime);
      max = w.round_to_3_places(w.wave_audio.etime - w.wave_display_length / 2);
      if (noffset > max) {
        noffset = max;
      }
      min = w.round_to_3_places(w.wave_display_length / 2);
      if (noffset < min) {
        noffset = min;
      }
      w.center_display_at_time(noffset);
      return console.log(`scroll ${w.wave_adjust_scroll}`);
    };
    // this handler would enable true scrolling, rather than just jumping
    // $(w.selector).on 'mousemove', '.waveform-scrollbar', (e) ->
    //     # return unless that.check_channel this
    //     return unless w.wave_adjust_scroll
    //     # selector = '.waveform-scrollbar'
    //     # rect = $(selector)[w.active_channel].getBoundingClientRect()
    //     rect = this.getBoundingClientRect()
    //     w.mousemove_x = e.clientX - rect.left
    //     scrollf w.mousemove_x
    $(w.selector).on('mousedown', '.waveform-scrollbar', function(e) {
      w.activate();
      return w.wave_adjust_scroll = true;
    });
    f = function(e) {
      var rect;
      if (this.debug) {
        console.log("mousemove_x");
        console.log(w);
      }
      // return unless that.check_channel this
      if (!w.wave_adjust_scroll) {
        return;
      }
      // selector = '.waveform-scrollbar'
      // rect = $(selector)[w.active_channel].getBoundingClientRect()
      rect = this.getBoundingClientRect();
      w.mouseup_x = e.clientX - rect.left;
      scrollf(w.mouseup_x);
      w.wave_adjust_scroll = false;
      return $('.keyboard').focus();
    };
    $(w.selector).on('mouseup', '.waveform-scrollbar', f);
    return $(w.selector).on('mouseleave', '.waveform-scrollbar', f);
  }

  // $('body').on 'mouseup', (e) ->
  //     w.wave_adjust_scroll =false
  mouse_swipe() {
    var w;
    w = this;
    w.set_mode_to_cursor();
    x = w.cursor_x();
    w.mousedown_x = x;
    w.set_mousedown_true();
    w.mouseup_x = x + 100;
    return w.set_mousedown_false();
  }
  // sets an endpoint for the selection
  // actually just sets the mousedown flag, but logically sets the start point
  set_mousedown_true() {
    var w;
    w = this;
    w.activate();
    w.mousedown = true;
    w.mouseup_x = false;
    w.mousemove_x = false;
    w.wave_adjust_time = w.wave_adjust_btime || w.wave_adjust_etime;
    if (this.debug) {
      console.log('updatedown');
    }
    return w.update_handles = true;
  }

  // sets a selection in concert with set_mousedown_true
  // only function that calls wave_update
  set_mousedown_false() {
    var b, e, length, mouseup_time, offset, p2s, w;
    w = this;
    console.log('a');
    if (!w.mousedown) {
      return;
    }
    console.log('b');
    if (w.wave_adjust_time) {
      if (w.mousemove_x) {
        mouseup_time = w.convert_pixels_to_seconds(w.mouseup_x) + w.wave_display_offset;
        if (w.wave_adjust_btime) {
          if (mouseup_time < w.wave_selection_end) {
            w.wave_update(mouseup_time, w.wave_selection_end - mouseup_time);
          }
        } else {
          if (w.wave_selection_offset < mouseup_time) {
            w.wave_update(w.wave_selection_offset, mouseup_time - w.wave_selection_offset);
          }
        }
      }
    } else {
      // the user can make the selection in either direction,
      // so here we normalize so begin is always less than end
      if (w.mouseup_x > w.mousedown_x) {
        b = w.mousedown_x;
        e = w.mouseup_x;
      } else {
        b = w.mouseup_x;
        e = w.mousedown_x;
      }
      p2s = w.convert_pixels_to_seconds; // only relative to visible region
      // the following only works if the displayed region didn't change,
      // in other words scrolling didn't occur during selection
      offset = w.convert_pixels_to_seconds(b) + w.wave_display_offset;
      length = w.convert_pixels_to_seconds(e - b);
      w.wave_update(offset, length);
    }
    if (this.debug) {
      console.log('updateup');
    }
    w.mousedown = false;
    w.wave_adjust_time = false;
    w.wave_adjust_scroll = false;
    return $('.keyboard').focus();
  }

  set_move_params(){
    const w = this;
    // return unless that.check_channel this
    w.wave_adjust_scroll = false;
    if (!w.wave_adjust_time) {
      w.wave_adjust_btime = false;
      w.wave_adjust_etime = false;
      // if w.mousedown_x and w.mousedown_x isnt w.mouseup_x
      if (w.wave_selection_length !== null && w.wave_selection_length !== 0) {
        if (true) { //Math.abs(e.clientY - rect.top - w.wave_canvas_height / 2) < 20
          if (Math.abs(w.mousemove_x - w.convert_seconds_to_pixels(w.wave_selection_offset - w.wave_display_offset)) < 20) {
            w.wave_adjust_btime = true;
          }
          if (Math.abs(w.mousemove_x - w.convert_seconds_to_pixels(w.wave_selection_end - w.wave_display_offset)) < 20) {
            w.wave_adjust_etime = true;
            w.wave_adjust_btime = false; // so they can't both be true
          }
        }
      }
    }
    if (this.debug) {
      time = w.round_to_3_places(w.convert_pixels_to_seconds(w.mousemove_x) + w.wave_display_offset).toString();
      console.log(`updatemove ${time} seconds`);
    }
    if (w.mousedown_x && !(w.wave_autoscroll || w.mouseup_x)) {
      w.autoscroll_jump();
    }
    // return w.update_cursor = true;
  }

  get_alignment() {
    var f2, f22, fn, text, w;
    w = this;
    text = '';
    $('.Transcription').each(function(i, x) {
      return text += $(x).data().value.value;
    });
    // text += ' blah'
    $('.ChannelA').after('<div class="waiting">Waiting</div>');
    f2 = function(data) {
      console.log('AINGDONE2');
      return console.log(data);
    };
    f22 = function(url) {
      if (this.external) {
        url = url.replace(':4567', '');
      }
      return $('body').prepend(`<a href=${url}>TextGrid</a>`);
    };
    x = '1A9AMW16Zk7GaSoCg6VgXg1k';
    fn = `s3://image-description/${x}`;
    return ldc_services.align({
      text: text,
      audio: fn,
      f22: f2
    });
  }

  add_timestamps2(data) {
    return this.interface.add_timestamps2(data);
  }

  add_timit() {
    var w;
    w = this;
    return ldc_nodes.getphtml('/file_set/get_uploads').then(function(data) {
      console.log(data);
      $('.Root').after(data);
      return $('.Root').hide();
    }).then(function() {
      var a;
      a = [[1, 2], [3, 4]];
      // w.add_timestamps a
      return ldc_nodes.get('/browser/index', function(data) {
        return console.log(data);
      });
    });
  }

  play_current_span_or_play_stop() {
    return this.component.play_current_span_or_play_stop();
  }

  play_from_cursor() {
    return this.component.play_from_cursor();
  }

  play_from_selection_beg() {
    return this.component.play_from_selection_beg();
  }

  play_from_selection_end() {
    return this.component.play_from_selection_end();
  }

  check_channel(x) {
    var event_channel;
    event_channel = parseInt($(x).parent().attr('id').split('-')[3]);
    return this.active_channel === event_channel;
  }

  switch_channel(x) {
    var event_channel, w;
    w = this;
    w.activate();
    return;
    event_channel = parseInt($(x).parent().attr('id').split('-')[3]);
    if (w.active_channel === 0 && event_channel === 1) {
      $('.channelb-button').click();
    }
    if (w.active_channel === 1 && event_channel === 0) {
      return $('.channela-button').click();
    }
  }

  // current selection == internal selection times
  // normally there's no difference between the visible selection and the "current" selection
  // when the mouse is down, there is a distinction, and this function syncs them back up,
  // changing the current selection to match the visible selection.
  // optionally modifies a transcript line as well to match this "current" selection (if there's an active line)
  // sets wave_selection_offset wave_length and wave_selection_end, and adjusts transcript line timestamps
  wave_update(span_offset, span_length) {
    var n, span_end, w;
    w = this;
    span_offset = w.round_to_3_places(span_offset);
    span_length = w.round_to_3_places(span_length);
    if (true) { //@debug
      console.log('update');
      console.log(span_offset);
      console.log(span_length);
      console.log(w.wave_selection_offset);
      console.log(w.wave_selection_length);
    }
    span_end = w.round_to_3_places(span_offset + span_length);
    if (this.debug) {
      if (w.wave_active_transcript_line) {
        console.log("active line before is " + w.wave_active_transcript_line.id.replace('node-', ''));
      } else {
        console.log("no active line");
      }
    }
    // this section handles updating a transcript line
    if (w.wave_selection_offset !== span_offset && w.wave_selection_end !== span_end) {
      console.log('setting to null');
      this.set_active_transcript_line(null);
    }
    if ((w.wave_selection_offset !== span_offset || w.wave_selection_length !== span_length) && w.wave_active_transcript_line) {
      console.log(w.selector);
      n = w.map.get(w.wave_active_transcript_line);
      console.log(n);
      n = $(`#${n}`).data().Segment.meta.id;
      // ww = if w.active_channel is 0 then w else waveform2
      ldc_annotate.add_message(n, 'change', {
        docid: w.wave_docid,
        beg: span_offset,
        end: span_end,
        play_head: span_offset,
        timestamps: true
      });
      ldc_annotate.submit_form();
      ldc_annotate.add_callback( () => update_segments() );
    }
    // end section
    w.set_current_selection(span_offset, span_length);
    if (this.debug) {
      if (w.wave_active_transcript_line) {
        return console.log("active line before is " + w.wave_active_transcript_line.id.replace('node-', ''));
      } else {
        return console.log('no active line');
      }
    }
  }

  // this assumes a certain front end, so really should be in SegmentList
  focus_input() {
    // $('.transcript-input').focus()
    return this.segments.refocus();
  }

  // $('.SegmentList').data().obj.focus_segment this.rmap[$('.crnt').attr('id')]
  set_active_transcript_line_to_last_created() {
    var avm, id, iid;
    avm = ldc_nodes.avm();
    if (avm.messages.length !== 0) {
      iid = avm.messages[avm.messages.length - 1].received.parent_id;
      id = $(`.segment-${iid}`).attr('id');
    } else {
      id = $('.segment').first().attr('id');
    }
    if (id) {
      return this.set_active_transcript_line(id);
    }
  }

  set_active_transcript_line_to_prev() {
    var ids, w;
    if ($('.ChannelA.active_channel').length !== 1) {
      return;
    }
    w = this;
    if (!w.segments) {
      w.segments = w.interface.segments;
    }
    ids = w.segments.set_active_transcript_line_to_prev();
    return w.set_active_transcript_line_helper(ids.id);
  }

  set_active_transcript_line_to_next() {
    var ids, w;
    if ($('.ChannelA.active_channel').length !== 1) {
      return;
    }
    w = this;
    if (!w.segments) {
      w.segments = w.interface.segments;
    }
    ids = w.segments.set_active_transcript_line_to_next();
    return w.set_active_transcript_line_helper(ids.id);
  }

  set_active_transcript_line_to_next_and_play_current_span() {
    var w;
    if ($('.ChannelA.active_channel').length !== 1) {
      return;
    }
    w = this;
    // Need a timeout otherwise next line is overwritten with (formerly) active transcript!
    return setTimeout(function() {
      w.set_active_transcript_line_to_next();
      return w.play_current_span();
    }, 200);
  }

  set_active_transcript_line(id, dont_focus) {
    var w;
    if ($('.ChannelA.active_channel').length !== 1) {
      return;
    }
    w = this;
    w.set_active_transcript_line_helper(id);
    if (!w.segments) {
      w.segments = w.interface.segments;
    }
    console.log(w.segments);
    return w.segments.set_active_transcript_line(id, dont_focus);
  }

  set_active_transcript_line_helper(id) {
    var node_id, play_head, same, src, srcc, w;
    w = this;
    if (true) { //@debug is true
      console.log("NODE");
      console.log(id);
    }
    if (!id) {
      id = null;
    }
    if (id && w.wave_active_transcript_line === id) {
      same = true;
    } else {
      same = false;
    }
    w.wave_active_transcript_line = id;
    if (id) {
      console.log(w.selector);
      node_id = w.map.get(id);
      console.log("active line is " + id + ':' + node_id);
      console.log(w.map);
      if (same === false) {
        // node = $("##{id}")
        // node.addClass('active-transcript-line')
        // src = $("##{node_id}").data().Segment.value
        srcc = w.interface.index2.get(id.split('-')[1]);
        w.activate(srcc.docid);
        src = {
          beg: srcc.beg,
          end: srcc.end
        };
        if (play_head !== src.end) {
          // if src.docid is w.wave_docid
          //     $(node).find('.btn').addClass('btn-primary')
          //     # $('.channela-button').click() if active_channel is 1
          // else if src.docid is waveform2.wave_docid
          //     $(node).find('.btn').addClass('btn-success')
          //     # $('.channelb-button').click() if active_channel is 0

          // element = node[0]
          // top = node.position().top
          // if node.position().top - node.parent().position().top > node.parent().height()
          //     element.scrollIntoView(false)
          // else if node.position().top - node.parent().position().top < 0
          //     element.scrollIntoView(true)

          // $("#{w.selector}")[0].scrollIntoView(false)
          play_head = src.beg;
        }
        w.show_src(src, true);
        if (this.debug === true) {
          console.log('showing source');
          console.log(src);
        }
        return ldc_nodes.current_hide_show(".ListItem", `#${node_id}`);
      }
    } else {
      // $('.crnt input').focus() unless dont_focus
      // $('.active-transcript-line input').focus() unless dont_focus
      console.log("no active line");
      return ldc_nodes.current_hide_show(".ListItem", "#noop");
    }
  }

  set_playing_transcript_line() {
    var found, w;
    w = this;
    if ($('.ChannelA.active_channel').length !== 1) {
      return;
    }
    found = w.helper.find_segment();
    if (found) {
      if (w.last_played_segment && w.last_played_segment !== found) {
        return w.last_played_segment = found;
      } else {
        $('.playing-transcript-line').removeClass('playing-transcript-line');
        return $(`#${found}`).addClass('playing-transcript-line');
      }
    } else {
      return $('.playing-transcript-line').removeClass('playing-transcript-line');
    }
  }

  set_current_selection(o, l) {
    var w;
    w = this;
    if (o < 0 || l < 0 || o > w.wave_audio.etime || o + l > w.wave_audio.etime) {
      return;
    }
    w.wave_selection_offset = o;
    w.wave_selection_length = l;
    w.wave_selection_end = w.round_to_3_places(o + l);
    // return w.update_cursor = true;
    selection.update( (x) => {
      return x;
    } );
  }

  show_src(src, beg) {
    var w;
    w = this;
    if (this.debug === true) {
      console.log(`BEGIN ${beg}`);
      console.log(src);
    }
    //this.set_active_transcript_line this
    w.set_current_selection_by_src(src);
    // w.update_waveform_canvas false if web_audio
    if (beg === true) {
      if (src.beg > w.wave_display_offset && ((w.wave_display_offset + w.wave_display_length) > src.beg)) {
        return console.log('within');
      } else {
        // this.update_waveform_canvas true # can the arg be false?
        console.log('without');
        console.log(`beg ${src.beg}`);
        return w.center_display_at_time(src.beg);
      }
    } else {
      if (src.end > w.wave_display_offset && ((w.wave_display_offset + w.wave_display_length) > src.end)) {
        return console.log('within');
      } else {
        // this.update_waveform_canvas true # can the arg be false?
        console.log('without');
        console.log(`beg ${src.end}`);
        return w.center_display_at_time(src.end);
      }
    }
  }

  // this.draw_underlines_audio_wave_docid()
  set_current_selection_by_src(src) {
    return this.set_current_selection(src.beg, this.round_to_3_places(src.end - src.beg));
  }

  autoscroll_jump() {
    var jump, s, w, width;
    w = this;
    width = w.wave_canvas_width / 100;
    jump = width * 50;
    s = w.convert_pixels_to_seconds(jump);
    if (w.mousemove_x < width && w.mousedown_x > width) {
      if (s < w.wave_display_offset) {
        w.mousedown_x += jump;
        w.set_times_then_draw(w.wave_display_offset - s, w.wave_display_length);
      }
      w.wave_autoscroll = true;
    } else if (w.wave_canvas_width - w.mousemove_x < width && w.wave_canvas_width - w.mousedown_x > width) {
      if (s + w.wave_display_offset + w.wave_display_length < w.wave_audio.etime) {
        w.mousedown_x -= jump;
        w.set_times_then_draw(w.wave_display_offset + s, w.wave_display_length);
      }
      w.wave_autoscroll = true;
    } else {
      w.wave_autoscroll = false;
    }
    if (w.wave_autoscroll) {
      return setTimeout(function() {
        return w.autoscroll_jump();
      }, 1000);
    }
  }


  center_display_at_time(c) {
    var b, w;
    w = this;
    // console.log 'centering at ' + c
    // console.log 'display length: ' + wave_display_length
    if (this.debug) {
      console.log(`center ${c}`);
    }
    b = c - w.wave_display_length / 2;
    w.set_times_then_draw(b, w.wave_display_length);
  }

  play_current_span_and_add_transcript_line_and_activate() {
    var w;
    w = this;
    w.play_current_span_and_add_transcript_line();
    return ldc_annotate.add_callback(function() {
      return w.set_active_transcript_line_to_last_created();
    });
  }

  play_current_span_and_add_transcript_line() {
    this.play_current_span();
    return this.add_transcript_line_based_on_selection();
  }

  add_transcript_line_based_on_selection() {
    return console.log('not implemented');
  }

  add_transcript_line_based_on_play_head() {
    return console.log('not implemented');
  }

  delete_active_transcript_line() {
    var w;
    w = this;
    x = w.set_active_transcript_line(null);
    if (x) {
      return w.delete_transcript_line_based_on_segment_id(x, true);
    }
  }

  delete_transcript_line_based_on_segment_id(x, submit) {
    var d, sel, w;
    w = this;
    sel = `#${w.map.get(x)}`;
    return w.delete_transcript_line_based_on_listitem_id($(sel).data().meta.id, submit);
  }

  delete_transcript_line_based_on_listitem_id(id, submit) {
    ldc_annotate.add_message(id, 'delete', null);
    if (submit) {
      ldc_annotate.submit_form();
      ldc_annotate.add_callback( () => update_segments() );
    }
  }

  add_transcript_line_and_activate() {
    var w;
    w = this;
    w.add_transcript_line_based_on_selection();
    return ldc_annotate.add_callback(function() {
      return w.set_active_transcript_line_to_last_created();
    });
  }

  get_add_transcript_line(list_selector, audio_path, type) {
    var w;
    w = this;
    return function() {
      var r;
      switch (type) {
        case 'selection':
          r = w.add_transcript_line_based_on_selection_without_submit(list_selector, audio_path);
          break;
        case 'play_head':
          r = w.add_transcript_line_based_on_play_head_without_submit(list_selector, audio_path);
          break;
        case 'split':
          r = w.add_transcript_line_split_without_submit(list_selector, audio_path);
          break;
        default:
          return;
      }
      if (r === 'submit') {
        ldc_annotate.submit_form();
        ldc_annotate.add_callback( () => update_segments() );
      }
    };
  }

  add_transcript_line_based_on_selection_without_submit(list_selector, audio_path) {
    var span, w;
    w = this;
    span = {
      offset: w.wave_selection_offset,
      length: w.wave_selection_length
    };
    return w.add_audio_to_list(list_selector, audio_path, span);
  }

  add_transcript_line_split_without_submit(list_selector, audio_path) {
    var span, time, w;
    w = this;
    time = w.convert_pixels_to_seconds(w.mousemove_x) + w.wave_display_offset;
    span = {
      offset: time + w.split_line_margin,
      length: w.round_to_3_places((w.wave_selection_length / 2) - w.split_line_margin)
    };
    return w.add_audio_to_list(list_selector, audio_path, span);
  }

  add_transcript_line_based_on_play_head_without_submit(list_selector, audio_path) {
    var found, span, w;
    w = this;
    found = w.helper.find_segment2();
    if (found || found === 0) {
      span = {
        offset: found,
        length: w.round_to_3_places(w.play_head - found)
      };
      return w.add_audio_to_list(list_selector, audio_path, span);
    }
  }

  add_audio_to_list(list_selector, audio_path, span) {
    return this.helper.add_audio_to_list(this.wave_docid, list_selector, audio_path, span);
  }

  close_kit() {
    if (ldc_nodes.get_constraint('close')) {
      console.log(1);
      return ldc_nodes.close_kit2();
    } else {
      console.log(2);
      return ldc_annotate.close_kit();
    }
  }

  add_to() {
    var input, orig, pos, y, z;
    input = $('input:focus');
    orig = input.val();
    pos = input[0].selectionStart;
    x = orig.substring(0, pos);
    y = '{blurb}';
    z = orig.substring(pos, orig.length);
    input.val(`${x}${y}${z}`);
    input[0].selectionStart = pos + y.length;
    return input[0].selectionEnd = pos + y.length;
  }

  // input.trigger 'change'
  // setTimeout ->
  //     $(input).focus()
  // , 1000
  get_sad_a() {
    return [[0.00, 0.54], [2.26, 10.94], [27.86, 28.38], [29.82, 30.35], [34.32, 39.54], [50.58, 51.11], [57.45, 65.45], [70.11, 70.62], [73.81, 75.29], [76.90, 79.59], [81.75, 91.73], [92.17, 104.67], [105.02, 110.18], [110.95, 111.50], [112.94, 119.93], [120.26, 126.05], [126.42, 130.84], [131.20, 137.43], [139.66, 140.17], [141.47, 152.97], [153.42, 161.17], [162.77, 164.69], [165.24, 176.41], [180.47, 181.08], [187.72, 188.98], [193.16, 195.18], [195.53, 203.83], [206.20, 213.36], [213.85, 215.38], [216.52, 217.15], [220.16, 222.26], [228.66, 229.35], [230.00, 230.85], [232.53, 233.08], [235.09, 238.14], [238.58, 243.73], [244.28, 250.60], [251.44, 252.30]];
  }

  special_settings() {
    var w;
    w = this;
    this.settings_modal.open_modal();
    $('#settings_modal .modal-body').html(settings);
    console.log(this.keyboards.help_screen_main.reset());
    $('#checkk').prop('checked', w.special === true);
    return $('.settings_pane').on('change', '#checkk', function(e) {
      return w.special = $(this).prop('checked');
    });
  }

  settings2() {
    return console.log('done');
  }

  open_guidelines() {
    var url;
    url = 'https://docs.google.com/document/d/e/2PACX-1vSTU3051TwfSjLorIpae_Yy5G6veJwuo1AXPW7fvVWlD-CIZ95KpQL2zyfV3FoRNBtf6JZARobEtGCz/pub';
    window.open(url, "webann_document_window", "toolbar=no,menubar=no,status=no,width=1000,height=500");
    return this.keyboards.help_screen_main.reset();
  }

  upload_transcript() {
    return this.component.upload_transcript();
  }

  // that = this
  // $('.Root').hide()
  // parser = new IbmTranscript that
  // h =
  //     w: that
  //     parser: parser
  // that.browse_a = new BrowseB
  //     target: $('.ann_pane')[0]
  //     props: h
  activate_sr() {
    var mainDiv;
    console.log("activate_sr");
    this.speechrecognition = true;
    mainDiv = $("<div class='speechrecognition'>Automatic Speech Recognition: ON</div>");
    $('.ChannelA').before(mainDiv);
    return SpeechRecognition.activate().then(function() {
      return setTimeout(function() {
        return mainDiv.remove();
      }, 1500);
    });
  }

  deactivate_sr() {
    console.log("deactivate_sr");
    this.speechrecognition = false;
    return SpeechRecognition.deactivate().then(function() {
      var mainDiv;
      mainDiv = $("<div class='speechrecognition'>Automatic Speech Recognition: OFF</div>");
      $('.ChannelA').before(mainDiv);
      return setTimeout(function() {
        return mainDiv.remove();
      }, 1500);
    });
  }

  switch_sr() {
    this.keyboards.services.reset();
    console.log("switch_sr");
    if (this.speechrecognition) {
      return this.deactivate_sr();
    } else {
      return this.activate_sr();
    }
  }

  info() {
    return console.log(this.datainfo);
  }

};

export {
  Waveform
};
