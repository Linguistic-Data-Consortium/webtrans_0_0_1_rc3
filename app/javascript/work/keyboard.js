// Generated by CoffeeScript 2.6.1
var Keyboard;

Keyboard = class Keyboard {
  constructor(name) {
    this.name = name;
    this.delegate = this;
  }

  set_map(map1) {
    this.map = map1;
  }

  set_delegate(delegate1) {
    this.delegate = delegate1;
  }

  shortcuts() {
    var i, j, results;
    results = [];
    for (i = j = 97; j <= 122; i = ++j) {
      results.push(String.fromCharCode(i));
    }
    return results;
  }

  reset() {
    // $('.Root').show()
    $('#node-00').show();
    $('#node-00-header').show();
    $('.segmentss').show();
    return $('.keyboard').focus();
  }

  root_hide() { // $('.Root').hide()
  }

  handle(e, mini) {
    var f;
    // f = w["keys_#{ss}"][e.key]
    f = this.map[e.key];
    if (f && f.match(/^nodes:/)) {
      return ldc_nodes[f.split(':')[1]]();
    } else if (f && f.match(/^work:/)) {
      return ldc_work[f.split(':')[1]]();
    } else if (f) {
      if (f === 'close') {
        this.reset();
        return f;
      } else {
        console.log(this.name);
        return this.delegate[f]();
      }
    } else {
      if (mini) {
        if (this.unknown_key_callback) {
          return this.unknown_key_callback();
        }
      } else {
        return this.help_screen_unknown();
      }
    }
  }

  // $('#mini_screen_speaker input').focus()
  // if false #hh is 'service'
  //     h = ldc_services.service_keys()
  //     console.log h
  //     console.log e.key
  //     switch h[e.key]
  //         when 'sad'
  //             w.add_sad()
  //         when 'alignment'
  //             console.log 'before'
  //             # w.add_timit()
  //             w.get_alignment()
  //             console.log 'after'
  help_screen_unknown() {
    this.reset();
    if (this.unknown_key_callback) {
      return this.unknown_key_callback();
    }
  }


  set_keyboard_icon(delegate) {
    var that;
    that = this;
    return $('.keyboard').on('keydown', function(e) {
      e.preventDefault();
      // w = $('.active_channel').data().waveform
      return that.fmap_helper(true, delegate, e);
    });
  }

  set_speaker_helper_new_helper(h, speakers) {
    speakers.push(['n', h.new_label]);
    this.map.n = 'getf';
    this.delegate[this.map.n] = h.getf;
  }


  open_menu(h){
    var hh, i, kb, map, short, speakerm, speakers, spkrs;
    kb = this;
    kb.map = {};
    short = kb.shortcuts();
    speakerm = {};
    spkrs = ldc_nodes.get_constraint(h.constraint);
    speakers = [];
    if (spkrs) {
      if (spkrs[0] === 'new') {
        kb.set_speaker_helper_new_helper(h, speakers);
        spkrs = spkrs.slice(1, spkrs.length);
      }
      $.each(spkrs, function(i, x) {
        return speakerm[x] = short[i];
      });
    } else {
      kb.set_speaker_helper_new_helper(h, speakers);
    }
    if (h.sel) {
      $(h.sel).each(function(i, y) {
        var x;
        x = $(y).data().value.value;
        if (x && !speakerm[x]) {
          return speakerm[x] = short[i];
        }
      });
    }
    i = 0;
    $.each(speakerm, function(x, cc) {
      var c;
      c = short[i];
      i += 1;
      speakers.push([c, x]);
      kb.map[c] = `setf_${c}`;
      kb.delegate[kb.map[c]] = function(){
        return h.setf(x);
      };
    });
    hh = {
      title: h.title,
      list: speakers,
      keyboard: kb,
      remove: true,
      reset: true,
      mini: true
    };
    // kb.show_mini_screen w, true
    h.help_screen.open(hh);
  }


};

export { Keyboard }
