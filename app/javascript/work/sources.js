// Generated by CoffeeScript 2.6.1
var Sources;

Sources = class Sources {
  constructor(name) {
    this.name = name;
    this.nodemap = {};
    this.begmap = {};
    this.endmap = {};
    this.srcs = {};
    this.sources = {};
    this.draw_underlines_flag = false;
    this.underline_height = 5;
  }

  set_draw_underlines_flag(b) {
    return this.draw_underlines_flag = b;
  }

  round_to_3_places(num) {
    return Math.round(num * 1000) / 1000;
  }

  add_source3(data) {
    var src, srcs;
    srcs = this.srcs;
    if (this.debug === true) {
      console.log('add source');
    }
    src = data.value;
    if (this.debug) {
      console.log("HELPER");
      console.log(src);
      console.log(data);
    }
    if (src.docid === null || src.docid === void 0) {
      return;
    }
    if (!srcs.hasOwnProperty(src.docid)) {
      srcs[src.docid] = {};
    }
    if (src.node) {
      srcs[src.docid][src.node] = src;
    } else {
      srcs[src.docid][data.meta.id] = src;
    }
    if (this.first_src === null) {
      this.first_src = src;
    }
    // if src.color
    //     $(node).css('color', src.color)
    if (this.debug === true) {
      return console.log(srcs);
    }
  }

  // * this function draws the actual underline using the jcanvas plugin
  // * note: if the text extends off the visible pane (width wise), it will only draw the visible portion
  draw_underline(offset, width, depth, selector, node_id) {
    var a, k, node, o, that, underline_color, underline_info, v, workflow, ww;
    that = this;
    if (this.debug) {
      console.log(`U4 ${offset} ${width} ${node_id}`);
    }
    node = that.draw_underline_helper1(node_id);
    if (node === false) {
      return;
    }
    underline_info = that.draw_underline_helper2(node);
    if (underline_info.bool === false) {
      return;
    }
    underline_color = underline_info.color;
    // depth = depth * ( underline_height * 2 + 1 )
    depth = depth * (this.underline_height + 5 + 1); // instead of doubling, just add 5
    if (ldc_nodes.get_constraint('rtl')) {
      ww = parseInt($(selector).css('width').replace('px', ''));
      // alert offset
      offset = ww - offset - width;
    }
    // alert offset
    o = {
      class: `underline_rect underline-rect-${node_id}`,
      width: width,
      height: this.underline_height,
      x: offset,
      y: depth,
      fill: underline_color
    };
    a = ['rect'];
    for (k in o) {
      v = o[k];
      a.push(k);
      a.push(v);
    }
    a.push('');
    return a;
  }

  draw_underline_helper1(node_id) {
    var node;
    node = $('#node-' + node_id).data();
    if (node) {
      return node;
    } else {
      return false;
    }
  }

  draw_underline_helper2(node) {
    var f, i, id_prefix, j, ref, ref1, textnode_value, textsource_id, that, underline_color, underline_info, workflow;
    that = this;
    underline_color = 'blue';
    if (node && node.value && node.value.color) {
      underline_color = node.value.color;
    }
    f = false;
    if (f) {
      underline_info = f(node.meta.id);
      if (underline_info.tooltip.length > 0) {
        textnode_value = ldc_annotate.get_node(underline_info.text_id).value;
        if (false) {
          textsource_id = workflow['getActiveTextSource']();
        } else {
          textsource_id = '#' + $('.current_display').attr('id');
        }
        id_prefix = textsource_id + '-char-';
        for (i = j = ref = textnode_value.beg, ref1 = textnode_value.end; (ref <= ref1 ? j < ref1 : j > ref1); i = ref <= ref1 ? ++j : --j) {
          $(id_prefix + i).attr('title', underline_info.tooltip);
        }
      }
      return underline_info;
    } else {
      return {
        color: underline_color
      };
    }
  }

  get_underline_info() {
    var workflow;
    // workflow = ldc_annotate.get_workflow();
    return workflow.get_underline_info || null;
  }


};

export {
  Sources
};
